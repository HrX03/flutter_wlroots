From a318f9775d15d552479eef4a07e800c52e3362af Mon Sep 17 00:00:00 2001
From: HrX03 <dn.bianco03@gmail.com>
Date: Fri, 11 Mar 2022 17:09:41 +0100
Subject: [PATCH 1/1] Fix key event sending to flutter

---
 demo/lib/main.dart         |   27 +-
 include/collection.h       |  555 ++++++++++++
 include/jsmn.h             |  471 ++++++++++
 include/platform_channel.h |  899 ++++++++++++++++++
 src/flutter_wlroots.c      |   31 +-
 src/input.c                |   94 +-
 src/meson.build            |    1 +
 src/platform_channel.c     | 1765 ++++++++++++++++++++++++++++++++++++
 8 files changed, 3761 insertions(+), 82 deletions(-)
 create mode 100644 include/collection.h
 create mode 100644 include/jsmn.h
 create mode 100644 include/platform_channel.h
 create mode 100644 src/platform_channel.c

diff --git a/demo/lib/main.dart b/demo/lib/main.dart
index 44c489a..084a05b 100644
--- a/demo/lib/main.dart
+++ b/demo/lib/main.dart
@@ -55,12 +55,6 @@ class MyHomePage extends StatefulWidget {
 }
 
 class _MyHomePageState extends State<MyHomePage> {
-  static const BasicMessageChannel<Object?> keyEvent =
-      BasicMessageChannel<Object?>(
-    'flutter/keyevent',
-    JSONMessageCodec(),
-  );
-
   int _counter = 0;
   Surface? surface;
 
@@ -79,21 +73,6 @@ class _MyHomePageState extends State<MyHomePage> {
     });
   }
 
-  @override
-  void initState() {
-    super.initState();
-    SystemChannels.keyEvent.setMessageHandler((message) async {
-      stdout.writeln(message);
-      return null;
-    });
-    /* platform.addHandler("flutter/keyevent", (call) async {
-      print('got event: ${call.arguments}');
-    }); */
-    RawKeyboard.instance.addListener((event) {
-      stdout.writeln(event);
-    });
-  }
-
   void _incrementCounter() {
     setState(() {
       // This call to setState tells the Flutter framework that something has
@@ -121,13 +100,11 @@ class _MyHomePageState extends State<MyHomePage> {
     // fast, so that you can just rebuild anything that needs updating rather
     // than having to individually change instances of widgets.
     return Focus(
-      onFocusChange: (value) {
-        stdout.writeln(value);
-      },
       onKeyEvent: (node, event) {
         stdout.writeln(event);
-        return KeyEventResult.ignored;
+        return KeyEventResult.handled;
       },
+      autofocus: true,
       child: Scaffold(
         appBar: AppBar(
           // Here we take the value from the MyHomePage object that was created by
diff --git a/include/collection.h b/include/collection.h
new file mode 100644
index 0000000..3035f01
--- /dev/null
+++ b/include/collection.h
@@ -0,0 +1,555 @@
+#ifndef _COLLECTION_H
+#define _COLLECTION_H
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <assert.h>
+#include <stdatomic.h>
+
+#include <pthread.h>
+
+struct queue {
+	size_t start_index;
+	size_t length;
+	size_t size;
+	void  *elements;
+
+	size_t max_queue_size;
+	size_t element_size;
+};
+
+struct concurrent_queue {
+	pthread_mutex_t mutex;
+	pthread_cond_t  is_dequeueable;
+	pthread_cond_t  is_enqueueable;
+	struct queue queue;
+};
+
+struct pointer_set {
+	/**
+	 * @brief The number of non-NULL pointers currently stored in @ref pointers. 
+	 */
+	size_t count_pointers;
+
+	/**
+	 * @brief The current size of the @ref pointers memory block, in pointers.
+	 */
+	size_t size;
+
+	/**
+	 * @brief The actual memory where the pointers are stored.
+	 */
+	void **pointers;
+
+	/**
+	 * @brief The maximum size of the @ref pointers memory block, in pointers.
+	 */
+	size_t max_size;
+
+	/**
+	 * @brief Whether this pointer_set is using static memory.
+	 */
+	bool is_static;
+};
+
+struct concurrent_pointer_set {
+	pthread_mutex_t mutex;
+	struct pointer_set set;
+};
+
+typedef _Atomic(int) refcount_t;
+
+#define QUEUE_DEFAULT_MAX_SIZE 64
+
+#define QUEUE_INITIALIZER(element_type, _max_size) \
+	((struct queue) { \
+		.start_index = 0, \
+		.length = 0, \
+		.size = 0, \
+		.elements = NULL, \
+		.max_queue_size = _max_queue_size, \
+		.element_size = sizeof(element_type) \
+	})
+
+#define CQUEUE_DEFAULT_MAX_SIZE 64
+
+#define CQUEUE_INITIALIZER(element_type, _max_size) \
+	((struct concurrent_queue) { \
+		.mutex = PTHREAD_MUTEX_INITIALIZER, \
+		.is_dequeueable = PTHREAD_COND_INITIALIZER, \
+		.is_enqueueable = PTHREAD_COND_INITIALIZER, \
+		.queue = QUEUE_INITIALIZER(element_type, _max_queue_size) \
+	})
+
+#define PSET_DEFAULT_MAX_SIZE 64
+
+#define PSET_INITIALIZER(_max_size) \
+	((struct pointer_set) { \
+		.count_pointers = 0, \
+		.size = 0, \
+		.pointers = NULL, \
+		.max_size = _max_size, \
+		.is_static = false \
+	})
+
+#define PSET_INITIALIZER_STATIC(_storage, _size) \
+	((struct pointer_set) { \
+		.count_pointers = 0, \
+		.size = _size, \
+		.pointers = _storage, \
+		.max_size = _size, \
+		.is_static = true \
+	})
+
+#define CPSET_DEFAULT_MAX_SIZE 64
+
+#define CPSET_INITIALIZER(_max_size) \
+	((struct concurrent_pointer_set) { \
+		.mutex = PTHREAD_MUTEX_INITIALIZER, \
+		.set = { \
+			.count_pointers = 0, \
+			.size = 0, \
+			.pointers = NULL, \
+			.max_size = _max_size, \
+			.is_static = false \
+		} \
+	})
+
+
+int queue_init(
+	struct queue *queue,
+	size_t element_size,
+	size_t max_queue_size
+);
+
+int queue_deinit(
+	struct queue *queue
+);
+
+int queue_enqueue(
+	struct queue *queue,
+	const void *p_element
+);
+
+int queue_dequeue(
+	struct queue *queue,
+	void *element_out
+);
+
+int queue_peek(
+	struct queue *queue,
+	void **pelement_out
+);
+
+
+int cqueue_init(
+	struct concurrent_queue *queue,
+	size_t element_size,
+	size_t max_queue_size
+);
+
+int cqueue_deinit(
+	struct concurrent_queue *queue
+);
+
+static inline int cqueue_lock(struct concurrent_queue * const queue) {
+	return pthread_mutex_lock(&queue->mutex);
+}
+
+static inline int cqueue_unlock(struct concurrent_queue * const queue) {
+	return pthread_mutex_unlock(&queue->mutex);
+}
+
+int cqueue_try_enqueue_locked(
+	struct concurrent_queue *queue,
+	const void *p_element
+);
+
+int cqueue_enqueue_locked(
+	struct concurrent_queue *queue,
+	const void *p_element
+);
+
+int cqueue_try_enqueue(
+	struct concurrent_queue *queue,
+	const void *p_element
+);
+
+int cqueue_enqueue(
+	struct concurrent_queue *queue,
+	const void *p_element
+);
+
+int cqueue_try_dequeue_locked(
+	struct concurrent_queue *queue,
+	void *element_out
+);
+
+int cqueue_dequeue_locked(
+	struct concurrent_queue *queue,
+	void *element_out
+);
+
+int cqueue_try_dequeue(
+	struct concurrent_queue *queue,
+	void *element_out
+);
+
+int cqueue_dequeue(
+	struct concurrent_queue *queue,
+	void *element_out
+);
+
+int cqueue_peek_locked(
+	struct concurrent_queue *queue,
+	void **pelement_out
+);
+
+/*
+ * pointer set
+ */
+int pset_init(
+	struct pointer_set *set,
+	size_t max_size
+);
+
+int pset_init_static(
+	struct pointer_set *set,
+	void **storage,
+	size_t size
+);
+
+void pset_deinit(
+	struct pointer_set *set
+);
+
+int pset_put(
+	struct pointer_set *set,
+	void *pointer
+);
+
+bool pset_contains(
+	const struct pointer_set *set,
+	const void *pointer
+);
+
+int pset_remove(
+	struct pointer_set *set,
+	const void *pointer
+);
+
+static inline int pset_get_count_pointers(
+	const struct pointer_set *set
+) {
+	return set->count_pointers;
+}
+
+/**
+ * @brief Returns the size of the internal storage of set, in pointers.
+ */
+static inline int pset_get_storage_size(
+	const struct pointer_set *set
+) {
+	return set->size;
+}
+
+int pset_copy(
+	const struct pointer_set *src,
+	struct pointer_set *dest
+);
+
+void pset_intersect(
+	struct pointer_set *src_dest,
+	const struct pointer_set *b
+);
+
+int pset_union(
+	struct pointer_set *src_dest,
+	const struct pointer_set *b
+);
+
+int pset_subtract(
+	struct pointer_set *minuend_difference,
+	const struct pointer_set *subtrahend
+);
+
+void *__pset_next_pointer(
+	struct pointer_set *set,
+	const void *pointer
+);
+
+#define for_each_pointer_in_pset(set, pointer) for ((pointer) = __pset_next_pointer(set, NULL); (pointer) != NULL; (pointer) = __pset_next_pointer(set, (pointer)))
+
+/*
+ * concurrent pointer set
+ */
+int cpset_init(
+	struct concurrent_pointer_set *set,
+	size_t max_size
+);
+
+void cpset_deinit(struct concurrent_pointer_set *set);
+
+static inline int cpset_lock(struct concurrent_pointer_set *set) {
+	return pthread_mutex_lock(&set->mutex);
+}
+
+static inline int cpset_unlock(struct concurrent_pointer_set *set) {
+	return pthread_mutex_unlock(&set->mutex);
+}
+
+static inline int cpset_put_locked(
+	struct concurrent_pointer_set *set,
+	void *pointer
+) {
+	return pset_put(&set->set, pointer);
+}
+
+static inline int cpset_put(
+	struct concurrent_pointer_set *set,
+	void *pointer
+) {
+	int ok;
+
+	cpset_lock(set);
+	ok = pset_put(&set->set, pointer);
+	cpset_unlock(set);
+
+	return ok;
+}
+
+static inline bool cpset_contains_locked(
+	struct concurrent_pointer_set *set,
+	const void *pointer
+) {
+	return pset_contains(&set->set, pointer);
+}
+
+static inline bool cpset_contains(
+	struct concurrent_pointer_set *set,
+	const void *pointer
+) {
+	bool result;
+
+	cpset_lock(set);
+	result = pset_contains(&set->set, pointer);
+	cpset_unlock(set);
+
+	return result;
+}
+
+static inline int cpset_remove_locked(
+	struct concurrent_pointer_set *set,
+	const void *pointer
+) {
+	return pset_remove(&set->set, pointer); 
+}
+
+static inline int cpset_remove(
+	struct concurrent_pointer_set *set,
+	const void *pointer
+) {
+	int ok;
+
+	cpset_lock(set);
+	ok = cpset_remove_locked(set, pointer);
+	cpset_unlock(set);
+
+	return ok;
+}
+
+static inline int cpset_get_count_pointers_locked(
+	const struct concurrent_pointer_set *set
+) {
+	return set->set.count_pointers;
+}
+
+/**
+ * @brief Returns the size of the internal storage of set, in pointers.
+ */
+static inline int cpset_get_storage_size_locked(
+	const struct concurrent_pointer_set *set
+) {
+	return set->set.size;
+}
+
+static inline int cpset_copy_into_pset_locked(
+	struct concurrent_pointer_set *src,
+	struct pointer_set *dest
+) {
+	return pset_copy(&src->set, dest);
+}
+
+static inline void *__cpset_next_pointer_locked(
+	struct concurrent_pointer_set *set,
+	const void *pointer
+) {
+	return __pset_next_pointer(&set->set, pointer);
+}
+
+#define for_each_pointer_in_cpset(set, pointer) for ((pointer) = __cpset_next_pointer_locked(set, NULL); (pointer) != NULL; (pointer) = __cpset_next_pointer_locked(set, (pointer)))
+
+static inline void *memdup(const void *restrict src, const size_t n) {
+	void *__restrict__ dest;
+
+	if ((src == NULL) || (n == 0)) return NULL;
+
+	dest = malloc(n);
+	if (dest == NULL) return NULL;
+
+	return memcpy(dest, src, n);
+}
+
+#define BMAP_DECLARATION(name, n_bits) uint8_t name[(((n_bits) - 1) / 8) + 1]
+#define BMAP_IS_SET(p_bmap, i_bit) ((p_bmap)[(i_bit) / sizeof(*(p_bmap))] & (1 << ((i_bit) & (sizeof(*(p_bmap)) - 1))))
+#define BMAP_SET(p_bmap, i_bit) ((p_bmap)[(i_bit) / sizeof(*(p_bmap))] |= (1 << ((i_bit) & (sizeof(*(p_bmap)) - 1))))
+#define BMAP_CLEAR(p_bmap, i_bit) ((p_bmap)[(i_bit) / sizeof(*(p_bmap))] &= ~(1 << ((i_bit) & (sizeof(*(p_bmap)) - 1))))
+#define BMAP_ZERO(p_bmap, n_bits) (memset((p_bmap), 0, (((n_bits) - 1) / 8) + 1))
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+
+/**
+ * @brief Get the current time of the system monotonic clock.
+ * @returns time in nanoseconds.
+ */
+static inline uint64_t get_monotonic_time(void) {
+	struct timespec time;
+	clock_gettime(CLOCK_MONOTONIC, &time);
+	return time.tv_nsec + time.tv_sec*1000000000ull;
+}
+
+#define FILE_DESCR(_logging_name) \
+static const char *__file_logging_name = _logging_name;
+
+#ifdef DEBUG
+#define DEBUG_ASSERT(__cond) assert(__cond)
+#define DEBUG_ASSERT_MSG(__cond, __msg) assert((__cond) && (__msg))
+#define LOG_ERROR(fmtstring, ...) fprintf(stderr, "[%s] " fmtstring, __file_logging_name, ##__VA_ARGS__)
+#define LOG_ERROR_UNPREFIXED(fmtstring, ...) fprintf(stderr, fmtstring, ##__VA_ARGS__)
+#define LOG_DEBUG(fmtstring, ...) fprintf(stderr, "[%s] " fmtstring, __file_logging_name, ##__VA_ARGS__)
+#define LOG_DEBUG_UNPREFIXED(fmtstring, ...) fprintf(stderr, fmtstring, ##__VA_ARGS__)
+#else
+#define DEBUG_ASSERT(__cond) do {} while (0)
+#define DEBUG_ASSERT_MSG(__cond, __msg) do {} while (0)
+#define LOG_ERROR(fmtstring, ...) fprintf(stderr, "[%s] " fmtstring, __file_logging_name, ##__VA_ARGS__)
+#define LOG_ERROR_UNPREFIXED(fmtstring, ...) fprintf(stderr, fmtstring, ##__VA_ARGS__)
+#define LOG_DEBUG(fmtstring, ...) do {} while (0)
+#define LOG_DEBUG_UNPREFIXED(fmtstring, ...) do {} while (0)
+#endif
+
+#define DEBUG_ASSERT_NOT_NULL(__var) DEBUG_ASSERT(__var != NULL)
+#define DEBUG_ASSERT_EQUALS(__a, __b) DEBUG_ASSERT((__a) == (__b))
+#define DEBUG_ASSERT_EGL_TRUE(__var) DEBUG_ASSERT((__var) == EGL_TRUE)
+
+#if !(201112L <= __STDC_VERSION__ || (!defined __STRICT_ANSI__ && (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR >= 6))))
+#	error "Needs C11 or later or GCC (not in pedantic mode) 4.6.0 or later for compile time asserts."
+#endif
+
+#define COMPILE_ASSERT_MSG(expression, msg) _Static_assert(expression, msg)
+#define COMPILE_ASSERT(expression) COMPILE_ASSERT_MSG(expression, "Expression evaluates to false")
+
+#define UNIMPLEMENTED() assert(0 && "Unimplemented")
+
+static inline int refcount_inc_n(refcount_t *refcount, int n) {
+	return atomic_fetch_add_explicit(refcount, n, memory_order_relaxed);
+}
+
+/// Increments the reference count and returns the previous value.
+static inline int refcount_inc(refcount_t *refcount) {
+	return refcount_inc_n(refcount, 1);
+}
+
+/// Decrement the reference count, return true if the refcount afterwards
+/// is still non-zero.
+static inline bool refcount_dec(refcount_t *refcount) {
+	return atomic_fetch_sub_explicit(refcount, 1, memory_order_acq_rel) != 1;
+}
+
+/// Returns true if the reference count is one.
+/// If this is the case you that means this thread has exclusive access
+/// to the object.
+static inline bool refcount_is_one(refcount_t *refcount) {
+	return atomic_load_explicit(refcount, memory_order_acquire) == 1;
+}
+
+/// Returns true if the reference count is zero. Should never be true
+/// in practice because that'd only be the case for a destroyed object.
+/// So this is only really useful for debugging.
+static inline bool refcount_is_zero(refcount_t *refcount) {
+	return atomic_load_explicit(refcount, memory_order_acquire) == 0;
+}
+
+/// Get the current reference count, without any memory ordering restrictions.
+/// Not strictly correct, should only be used for debugging. 
+static inline int refcount_get_for_debug(refcount_t *refcount) {
+	return atomic_load_explicit(refcount, memory_order_relaxed);
+}
+
+#define REFCOUNT_INIT_0 (0)
+#define REFCOUNT_INIT_1 (1)
+#define REFCOUNT_INIT_N(n) (n)
+
+#define DECLARE_REF_OPS(obj_name) \
+struct obj_name *obj_name ## _ref(struct obj_name *obj); \
+void obj_name ## _unref(struct obj_name *obj); \
+void obj_name ## _unrefp(struct obj_name **obj); \
+
+#define DEFINE_REF_OPS(obj_name, refcount_member_name) \
+struct obj_name *obj_name ## _ref(struct obj_name *obj) { \
+	refcount_inc(&obj->refcount_member_name); \
+	return obj; \
+} \
+void obj_name ## _unref(struct obj_name *obj) { \
+	if (refcount_dec(&obj->refcount_member_name) == false) { \
+		obj_name ## _destroy(obj); \
+	} \
+} \
+void obj_name ## _unrefp(struct obj_name **obj) { \
+	obj_name ## _unref(*obj); \
+	*obj = NULL; \
+}
+
+#define DECLARE_LOCK_OPS(obj_name) \
+void obj_name ## _lock(struct obj_name *obj); \
+void obj_name ## _unlock(struct obj_name *obj);
+
+#define DEFINE_LOCK_OPS(obj_name, mutex_member_name) \
+void obj_name ## _lock(struct obj_name *obj) { \
+	pthread_mutex_lock(&obj->mutex_member_name); \
+} \
+void obj_name ## _unlock(struct obj_name *obj) { \
+	pthread_mutex_unlock(&obj->mutex_member_name); \
+}
+
+#define DEFINE_STATIC_LOCK_OPS(obj_name, mutex_member_name) \
+static void obj_name ## _lock(struct obj_name *obj) { \
+	pthread_mutex_lock(&obj->mutex_member_name); \
+} \
+static void obj_name ## _unlock(struct obj_name *obj) { \
+	pthread_mutex_unlock(&obj->mutex_member_name); \
+}
+
+#define DEFINE_INLINE_LOCK_OPS(obj_name, mutex_member_name) \
+static inline void obj_name ## _lock(struct obj_name *obj) { \
+	pthread_mutex_lock(&obj->mutex_member_name); \
+} \
+static inline void obj_name ## _unlock(struct obj_name *obj) { \
+	pthread_mutex_unlock(&obj->mutex_member_name); \
+}
+
+#define BITCAST(to_type, value) (*((const to_type*) (&(value))))
+
+static inline int32_t uint32_to_int32(const uint32_t v) {
+	return BITCAST(int32_t, v);
+}
+
+static inline uint32_t int32_to_uint32(const int32_t v) {
+	return BITCAST(uint32_t, v);
+}
+
+#endif
\ No newline at end of file
diff --git a/include/jsmn.h b/include/jsmn.h
new file mode 100644
index 0000000..764bb2f
--- /dev/null
+++ b/include/jsmn.h
@@ -0,0 +1,471 @@
+/*
+ * MIT License
+ *
+ * Copyright (c) 2010 Serge Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef JSMN_H
+#define JSMN_H
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef JSMN_STATIC
+#define JSMN_API static
+#else
+#define JSMN_API extern
+#endif
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ * 	o String
+ * 	o Other primitive: number, boolean (true/false) or null
+ */
+typedef enum {
+  JSMN_UNDEFINED = 0,
+  JSMN_OBJECT = 1,
+  JSMN_ARRAY = 2,
+  JSMN_STRING = 3,
+  JSMN_PRIMITIVE = 4
+} jsmntype_t;
+
+enum jsmnerr {
+  /* Not enough tokens were provided */
+  JSMN_ERROR_NOMEM = -1,
+  /* Invalid character inside JSON string */
+  JSMN_ERROR_INVAL = -2,
+  /* The string is not a full JSON packet, more bytes expected */
+  JSMN_ERROR_PART = -3
+};
+
+/**
+ * JSON token description.
+ * type		type (object, array, string etc.)
+ * start	start position in JSON data string
+ * end		end position in JSON data string
+ */
+typedef struct {
+  jsmntype_t type;
+  int start;
+  int end;
+  int size;
+#ifdef JSMN_PARENT_LINKS
+  int parent;
+#endif
+} jsmntok_t;
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string.
+ */
+typedef struct {
+  unsigned int pos;     /* offset in the JSON string */
+  unsigned int toknext; /* next token to allocate */
+  int toksuper;         /* superior token node, e.g. parent object or array */
+} jsmn_parser;
+
+/**
+ * Create JSON parser over an array of tokens
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser);
+
+/**
+ * Run JSON parser. It parses a JSON data string into and array of tokens, each
+ * describing
+ * a single JSON object.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens);
+
+#ifndef JSMN_HEADER
+/**
+ * Allocates a fresh unused token from the token pool.
+ */
+static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
+                                   const size_t num_tokens) {
+  jsmntok_t *tok;
+  if (parser->toknext >= num_tokens) {
+    return NULL;
+  }
+  tok = &tokens[parser->toknext++];
+  tok->start = tok->end = -1;
+  tok->size = 0;
+#ifdef JSMN_PARENT_LINKS
+  tok->parent = -1;
+#endif
+  return tok;
+}
+
+/**
+ * Fills token type and boundaries.
+ */
+static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
+                            const int start, const int end) {
+  token->type = type;
+  token->start = start;
+  token->end = end;
+  token->size = 0;
+}
+
+/**
+ * Fills next available token with JSON primitive.
+ */
+static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
+                                const size_t len, jsmntok_t *tokens,
+                                const size_t num_tokens) {
+  jsmntok_t *token;
+  int start;
+
+  start = parser->pos;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    switch (js[parser->pos]) {
+#ifndef JSMN_STRICT
+    /* In strict mode primitive must be followed by "," or "}" or "]" */
+    case ':':
+#endif
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+    case ',':
+    case ']':
+    case '}':
+      goto found;
+    default:
+                   /* to quiet a warning from gcc*/
+      break;
+    }
+    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+      parser->pos = start;
+      return JSMN_ERROR_INVAL;
+    }
+  }
+#ifdef JSMN_STRICT
+  /* In strict mode primitive must be followed by a comma/object/array */
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+#endif
+
+found:
+  if (tokens == NULL) {
+    parser->pos--;
+    return 0;
+  }
+  token = jsmn_alloc_token(parser, tokens, num_tokens);
+  if (token == NULL) {
+    parser->pos = start;
+    return JSMN_ERROR_NOMEM;
+  }
+  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+  token->parent = parser->toksuper;
+#endif
+  parser->pos--;
+  return 0;
+}
+
+/**
+ * Fills next token with JSON string.
+ */
+static int jsmn_parse_string(jsmn_parser *parser, const char *js,
+                             const size_t len, jsmntok_t *tokens,
+                             const size_t num_tokens) {
+  jsmntok_t *token;
+
+  int start = parser->pos;
+
+  parser->pos++;
+
+  /* Skip starting quote */
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c = js[parser->pos];
+
+    /* Quote: end of string */
+    if (c == '\"') {
+      if (tokens == NULL) {
+        return 0;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        parser->pos = start;
+        return JSMN_ERROR_NOMEM;
+      }
+      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+      token->parent = parser->toksuper;
+#endif
+      return 0;
+    }
+
+    /* Backslash: Quoted symbol expected */
+    if (c == '\\' && parser->pos + 1 < len) {
+      int i;
+      parser->pos++;
+      switch (js[parser->pos]) {
+      /* Allowed escaped symbols */
+      case '\"':
+      case '/':
+      case '\\':
+      case 'b':
+      case 'f':
+      case 'r':
+      case 'n':
+      case 't':
+        break;
+      /* Allows escaped symbol \uXXXX */
+      case 'u':
+        parser->pos++;
+        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
+             i++) {
+          /* If it isn't a hex character we have an error */
+          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
+                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */
+                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
+            parser->pos = start;
+            return JSMN_ERROR_INVAL;
+          }
+          parser->pos++;
+        }
+        parser->pos--;
+        break;
+      /* Unexpected symbol */
+      default:
+        parser->pos = start;
+        return JSMN_ERROR_INVAL;
+      }
+    }
+  }
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+}
+
+/**
+ * Parse JSON string and fill tokens.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens) {
+  int r;
+  int i;
+  jsmntok_t *token;
+  int count = parser->toknext;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c;
+    jsmntype_t type;
+
+    c = js[parser->pos];
+    switch (c) {
+    case '{':
+    case '[':
+      count++;
+      if (tokens == NULL) {
+        break;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        return JSMN_ERROR_NOMEM;
+      }
+      if (parser->toksuper != -1) {
+        jsmntok_t *t = &tokens[parser->toksuper];
+#ifdef JSMN_STRICT
+        /* In strict mode an object or array can't become a key */
+        if (t->type == JSMN_OBJECT) {
+          return JSMN_ERROR_INVAL;
+        }
+#endif
+        t->size++;
+#ifdef JSMN_PARENT_LINKS
+        token->parent = parser->toksuper;
+#endif
+      }
+      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+      token->start = parser->pos;
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case '}':
+    case ']':
+      if (tokens == NULL) {
+        break;
+      }
+      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+#ifdef JSMN_PARENT_LINKS
+      if (parser->toknext < 1) {
+        return JSMN_ERROR_INVAL;
+      }
+      token = &tokens[parser->toknext - 1];
+      for (;;) {
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          token->end = parser->pos + 1;
+          parser->toksuper = token->parent;
+          break;
+        }
+        if (token->parent == -1) {
+          if (token->type != type || parser->toksuper == -1) {
+            return JSMN_ERROR_INVAL;
+          }
+          break;
+        }
+        token = &tokens[token->parent];
+      }
+#else
+      for (i = parser->toknext - 1; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          parser->toksuper = -1;
+          token->end = parser->pos + 1;
+          break;
+        }
+      }
+      /* Error if unmatched closing bracket */
+      if (i == -1) {
+        return JSMN_ERROR_INVAL;
+      }
+      for (; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          parser->toksuper = i;
+          break;
+        }
+      }
+#endif
+      break;
+    case '\"':
+      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+      break;
+    case ':':
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case ',':
+      if (tokens != NULL && parser->toksuper != -1 &&
+          tokens[parser->toksuper].type != JSMN_ARRAY &&
+          tokens[parser->toksuper].type != JSMN_OBJECT) {
+#ifdef JSMN_PARENT_LINKS
+        parser->toksuper = tokens[parser->toksuper].parent;
+#else
+        for (i = parser->toknext - 1; i >= 0; i--) {
+          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
+            if (tokens[i].start != -1 && tokens[i].end == -1) {
+              parser->toksuper = i;
+              break;
+            }
+          }
+        }
+#endif
+      }
+      break;
+#ifdef JSMN_STRICT
+    /* In strict mode primitives are: numbers and booleans */
+    case '-':
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+    case 't':
+    case 'f':
+    case 'n':
+      /* And they must not be keys of the object */
+      if (tokens != NULL && parser->toksuper != -1) {
+        const jsmntok_t *t = &tokens[parser->toksuper];
+        if (t->type == JSMN_OBJECT ||
+            (t->type == JSMN_STRING && t->size != 0)) {
+          return JSMN_ERROR_INVAL;
+        }
+      }
+#else
+    /* In non-strict mode every unquoted value is a primitive */
+    default:
+#endif
+      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+
+#ifdef JSMN_STRICT
+    /* Unexpected char in strict mode */
+    default:
+      return JSMN_ERROR_INVAL;
+#endif
+    }
+  }
+
+  if (tokens != NULL) {
+    for (i = parser->toknext - 1; i >= 0; i--) {
+      /* Unmatched opened object or array */
+      if (tokens[i].start != -1 && tokens[i].end == -1) {
+        return JSMN_ERROR_PART;
+      }
+    }
+  }
+
+  return count;
+}
+
+/**
+ * Creates a new parser based over a given buffer with an array of tokens
+ * available.
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser) {
+  parser->pos = 0;
+  parser->toknext = 0;
+  parser->toksuper = -1;
+}
+
+#endif /* JSMN_HEADER */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* JSMN_H */
\ No newline at end of file
diff --git a/include/platform_channel.h b/include/platform_channel.h
new file mode 100644
index 0000000..d036b47
--- /dev/null
+++ b/include/platform_channel.h
@@ -0,0 +1,899 @@
+#ifndef _METHODCHANNEL_H
+#define _METHODCHANNEL_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <flutter_embedder.h>
+#include <collection.h>
+
+#include "platform_channel.h"
+
+#define JSON_DECODE_TOKENLIST_SIZE  128
+
+#define FLUTTER_RESULT_TO_STRING(result) \
+	((result) == kSuccess ? "Success." : \
+	 (result) == kInvalidLibraryVersion ? "Invalid library version." : \
+	 (result) == kInvalidArguments ? "Invalid arguments." : \
+	 (result) == kInternalInconsistency ? "Internal inconsistency." : "(?)")
+
+/*
+ * It may be simpler for plugins if the two message value types were unified.
+ * But from a performance POV, this doesn't make sense. number arrays in StandardMessageCodec
+ * are 4 or 8 -byte aligned for faster access. We don't have to copy them, StdMsgCodecValue.int64array (as an example)
+ * is just a pointer to that portion of the buffer, where the array is located.
+ * 
+ * However, JSON and thus JSON Message Handlers have no idea what a int64array is, they just know of JSON arrays.
+ * This means we'd have to implicitly convert the int64array into a JSON array when we want to unify the two message value types,
+ * and this costs all the performance we (more precisely, the flutter engineers) gained by memory-aligning the arrays in StdMsgCodecValue.
+ * 
+ * Let's just hope the flutter team doesn't randomly switch codecs of platform channels. Receive Handlers would
+ * need to be rewritten every time they do. The handlers not needing to be rewritten would probably be the only advantage
+ * of using a unified message value type.
+ */
+enum json_value_type {
+    kJsonNull,
+    kJsonTrue,
+    kJsonFalse,
+    kJsonNumber,
+    kJsonString,
+    kJsonArray, 
+    kJsonObject
+};
+struct json_value {
+    enum json_value_type type;
+    union {
+        double number_value;
+        char  *string_value;
+        struct {
+            size_t size;
+            union {
+                struct json_value *array;
+                struct {
+                    char                    **keys;
+                    struct json_value *values;
+                };
+            };
+        };
+    };
+};
+
+enum std_value_type {
+    kStdNull = 0,
+    kStdTrue,
+    kStdFalse,
+    kStdInt32,
+    kStdInt64,
+    kStdLargeInt, // treat as kString
+    kStdFloat64,
+    kStdString,
+    kStdUInt8Array,
+    kStdInt32Array,
+    kStdInt64Array,
+    kStdFloat64Array,
+    kStdList,
+    kStdMap
+};
+struct std_value {
+    enum std_value_type type;
+    union {
+        bool    bool_value;
+        int32_t int32_value;
+        int64_t int64_value;
+        double  float64_value;
+        char*   string_value;
+        struct {
+            size_t size;
+            union {
+                uint8_t* uint8array;
+                int32_t* int32array;
+                int64_t* int64array;
+                double*  float64array;
+                struct std_value* list;
+                struct {
+                    struct std_value* keys;
+                    struct std_value* values;
+                };
+            };
+        };
+    };
+};
+
+struct std_value_v2 {
+	enum std_value_type type;
+};
+
+#define STDVALUE_IS_NULL(value) ((value).type == kStdNull)
+#define STDNULL ((struct std_value) {.type = kStdNull})
+
+#define STDVALUE_IS_BOOL(value) (((value).type == kStdTrue) || ((value).type == kStdFalse))
+#define STDVALUE_AS_BOOL(value) ((value).type == kStdTrue)
+#define STDBOOL(bool_value) ((struct std_value) {.type = (bool_value) ? kStdTrue : kStdFalse})
+
+#define STDVALUE_IS_INT(value) (((value).type == kStdInt32) || ((value).type == kStdInt64))
+#define STDVALUE_AS_INT(value) ((value).type == kStdInt32 ? (int64_t) (value).int32_value : (value).int64_value)
+#define STDINT32(_int32_value) ((struct std_value) {.type = kStdInt32, .int32_value = (_int32_value)})
+#define STDINT64(_int64_value) ((struct std_value) {.type = kStdInt64, .int64_value = (_int64_value)})
+
+#define STDVALUE_IS_FLOAT(value) ((value).type == kStdFloat64)
+#define STDVALUE_AS_FLOAT(value) ((value).float64_value)
+#define STDFLOAT64(double_value) ((struct std_value) {.type = kStdFloat64, .float64_value = (double_value)})
+
+#define STDVALUE_IS_NUM(value) (STDVALUE_IS_INT(value) || STDVALUE_IS_FLOAT(value))
+#define STDVALUE_AS_NUM(value) (STDVALUE_IS_INT(value) ? STDVALUE_AS_INT(value) : STDVALUE_AS_FLOAT(value))
+
+#define STDVALUE_IS_STRING(value) ((value).type == kStdString)
+#define STDVALUE_AS_STRING(value) ((value).string_value)
+#define STDSTRING(str) ((struct std_value) {.type = kStdString, .string_value = (str)})
+
+#define STDVALUE_IS_LIST(value) ((value).type == kStdList)
+#define STDVALUE_IS_SIZE(value, _size) ((value).size == (_size))
+#define STDVALUE_IS_SIZED_LIST(value, _size) (STDVALUE_IS_LIST(value) && STDVALUE_IS_SIZE(value, _size))
+
+#define STDVALUE_IS_INT_ARRAY(value) (((value).type == kStdInt32Array) || ((value).type == kStdInt64Array) || ((value).type == kStdUInt8Array))
+#define STDVALUE_IS_FLOAT_ARRAY(value) ((value).type == kStdFloat64Array)
+#define STDVALUE_IS_NUM_ARRAY(value) (STDVALUE_IS_INT_ARRAY(value) || STDVALUE_IS_FLOAT_ARRAY(value))
+
+#define STDVALUE_IS_MAP(value) ((value).type == kStdMap)
+#define STDVALUE_IS_SIZED_MAP(value, _size) ((value).size == (_size))
+
+#define STDMAP1(key1, val1) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 1, \
+	.keys = (struct std_value[1]) { \
+		(key1) \
+	}, \
+	.values = (struct std_value[1]) { \
+		(val1) \
+	} \
+})
+
+#define STDMAP2(key1, val1, key2, val2) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 2, \
+	.keys = (struct std_value[2]) { \
+		(key1), (key2) \
+	}, \
+	.values = (struct std_value[2]) { \
+		(val1), (val2) \
+	} \
+})
+#define STDMAP3(key1, val1, key2, val2, key3, val3) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 3, \
+	.keys = (struct std_value[3]) { \
+		(key1), (key2), (key3) \
+	}, \
+	.values = (struct std_value[3]) { \
+		(val1), (val2), (val3) \
+	} \
+})
+#define STDMAP4(key1, val1, key2, val2, key3, val3, key4, val4) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 4, \
+	.keys = (struct std_value[4]) { \
+		(key1), (key2), (key3), (key4) \
+	}, \
+	.values = (struct std_value[4]) { \
+		(val1), (val2), (val3), (val4) \
+	} \
+})
+#define STDMAP5(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 5, \
+	.keys = (struct std_value[5]) { \
+		(key1), (key2), (key3), (key4), (key5) \
+	}, \
+	.values = (struct std_value[5]) { \
+		(val1), (val2), (val3), (val4), (val5) \
+	} \
+})
+#define STDMAP6(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 6, \
+	.keys = (struct std_value[6]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6) \
+	}, \
+	.values = (struct std_value[6]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6) \
+	} \
+})
+#define STDMAP7(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 7, \
+	.keys = (struct std_value[7]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7) \
+	}, \
+	.values = (struct std_value[7]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7) \
+	} \
+})
+#define STDMAP8(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 8, \
+	.keys = (struct std_value[8]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8) \
+	}, \
+	.values = (struct std_value[8]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8) \
+	} \
+})
+#define STDMAP9(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 9, \
+	.keys = (struct std_value[9]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9) \
+	}, \
+	.values = (struct std_value[9]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9) \
+	} \
+})
+#define STDMAP10(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 10, \
+	.keys = (struct std_value[10]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10) \
+	}, \
+	.values = (struct std_value[10]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10) \
+	} \
+})
+#define STDMAP11(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 11, \
+	.keys = (struct std_value[11]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11) \
+	}, \
+	.values = (struct std_value[11]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11) \
+	} \
+})
+#define STDMAP12(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 12, \
+	.keys = (struct std_value[12]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12) \
+	}, \
+	.values = (struct std_value[12]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12) \
+	} \
+})
+#define STDMAP13(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 13, \
+	.keys = (struct std_value[13]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13) \
+	}, \
+	.values = (struct std_value[13]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13) \
+	} \
+})
+#define STDMAP14(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 14, \
+	.keys = (struct std_value[14]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14) \
+	}, \
+	.values = (struct std_value[14]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14) \
+	} \
+})
+#define STDMAP15(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 15, \
+	.keys = (struct std_value[15]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15) \
+	}, \
+	.values = (struct std_value[15]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15) \
+	} \
+})
+#define STDMAP16(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 16, \
+	.keys = (struct std_value[16]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16) \
+	}, \
+	.values = (struct std_value[16]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16) \
+	} \
+})
+#define STDMAP17(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 17, \
+	.keys = (struct std_value[17]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17) \
+	}, \
+	.values = (struct std_value[17]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17) \
+	} \
+})
+#define STDMAP18(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17, key18, val18) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 18, \
+	.keys = (struct std_value[18]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17), (key18) \
+	}, \
+	.values = (struct std_value[18]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17), (val18) \
+	} \
+})
+#define STDMAP19(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17, key18, val18, key19, val19) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 19, \
+	.keys = (struct std_value[19]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17), (key18), (key19) \
+	}, \
+	.values = (struct std_value[19]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17), (val18), (val19) \
+	} \
+})
+#define STDMAP20(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17, key18, val18, key19, val19, key20, val20) ((struct std_value) { \
+	.type = kStdMap, \
+	.size = 20, \
+	.keys = (struct std_value[20]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17), (key18), (key19), (key20) \
+	}, \
+	.values = (struct std_value[20]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17), (val18), (val19), (val20) \
+	} \
+})
+
+#define STDLIST1(val1) ((struct std_value) { \
+	.type = kStdList, \
+	.size = 1, \
+	.list = (struct std_value[1]) { \
+		(val1) \
+	} \
+})
+
+#define STDLIST2(val1, val2) ((struct std_value) { \
+	.type = kStdList, \
+	.size = 2, \
+	.list = (struct std_value[2]) { \
+		(val1), (val2) \
+	} \
+})
+
+#define JSONVALUE_IS_NULL(value) ((value).type == kJsonNull)
+#define JSONNULL ((struct json_value) {.type = kJsonNull})
+
+#define JSONVALUE_IS_BOOL(value) (((value).type == kJsonTrue) || ((value).type == kJsonFalse))
+#define JSONVALUE_AS_BOOL(value) ((value).type == kJsonTrue)
+#define JSONBOOL(bool_value) ((struct json_value) {.type = (bool_value) ? kJsonTrue : kJsonFalse})
+
+#define JSONVALUE_IS_NUM(value) ((value).type == kJsonNumber)
+#define JSONVALUE_AS_NUM(value) ((value).number_value)
+#define JSONNUM(_number_value) ((struct json_value) {.type = kJsonNumber, .number_value = (_number_value)})
+
+#define JSONVALUE_IS_STRING(value) ((value).type == kJsonString)
+#define JSONVALUE_AS_STRING(value) ((value).string_value)
+#define JSONSTRING(str) ((struct json_value) {.type = kJsonString, .string_value = str})
+
+#define JSONVALUE_IS_ARRAY(value) ((value).type == kJsonArray)
+#define JSONVALUE_IS_SIZE(value, _size) ((value).size == (_size))
+#define JSONVALUE_IS_SIZED_ARRAY(value, _size) (JSONVALUE_IS_ARRAY(value) && JSONVALUE_IS_SIZE(value, _size))
+
+#define JSONVALUE_IS_OBJECT(value) ((value).type == kJsonObject)
+#define JSONVALUE_IS_SIZED_OBJECT(value, _size) (JSONVALUE_IS_OBJECT(value) && JSONVALUE_IS_SIZE(value, _size))
+
+#define JSONARRAY1(val1) ((struct json_value) { \
+	.type = kJsonArray, \
+	.size = 1, \
+	.array = (struct json_value[1]) { \
+		(val1) \
+	} \
+})
+#define JSONARRAY2(val1, val2) ((struct json_value) { \
+	.type = kJsonArray, \
+	.size = 2, \
+	.array = (struct json_value[2]) { \
+		(val1), (val2) \
+	} \
+})
+#define JSONARRAY3(val1, val2, val3) ((struct json_value) { \
+	.type = kJsonArray, \
+	.size = 3, \
+	.array = (struct json_value[3]) { \
+		(val1), (val2), (val3) \
+	} \
+})
+
+#define JSONOBJECT1(key1, val1) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 1, \
+	.keys = (char *[1]) { \
+		(key1) \
+	}, \
+	.values = (struct json_value[1]) { \
+		(val1) \
+	} \
+})
+
+#define JSONOBJECT2(key1, val1, key2, val2) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 2, \
+	.keys = (char *[2]) { \
+		(key1), (key2) \
+	}, \
+	.values = (struct json_value[2]) { \
+		(val1), (val2) \
+	} \
+})
+#define JSONOBJECT3(key1, val1, key2, val2, key3, val3) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 3, \
+	.keys = (char *[3]) { \
+		(key1), (key2), (key3) \
+	}, \
+	.values = (struct json_value[3]) { \
+		(val1), (val2), (val3) \
+	} \
+})
+#define JSONOBJECT4(key1, val1, key2, val2, key3, val3, key4, val4) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 4, \
+	.keys = (char *[4]) { \
+		(key1), (key2), (key3), (key4) \
+	}, \
+	.values = (struct json_value[4]) { \
+		(val1), (val2), (val3), (val4) \
+	} \
+})
+#define JSONOBJECT5(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 5, \
+	.keys = (char *[5]) { \
+		(key1), (key2), (key3), (key4), (key5) \
+	}, \
+	.values = (struct json_value[5]) { \
+		(val1), (val2), (val3), (val4), (val5) \
+	} \
+})
+#define JSONOBJECT6(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 6, \
+	.keys = (char *[6]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6) \
+	}, \
+	.values = (struct json_value[6]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6) \
+	} \
+})
+#define JSONOBJECT7(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 7, \
+	.keys = (char *[7]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7) \
+	}, \
+	.values = (struct json_value[7]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7) \
+	} \
+})
+#define JSONOBJECT8(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 8, \
+	.keys = (char *[8]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8) \
+	}, \
+	.values = (struct json_value[8]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8) \
+	} \
+})
+#define JSONOBJECT9(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 9, \
+	.keys = (char *[9]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9) \
+	}, \
+	.values = (struct json_value[9]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9) \
+	} \
+})
+#define JSONOBJECT10(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 10, \
+	.keys = (char *[10]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10) \
+	}, \
+	.values = (struct json_value[10]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10) \
+	} \
+})
+#define JSONOBJECT11(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 11, \
+	.keys = (char *[11]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11) \
+	}, \
+	.values = (struct json_value[11]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11) \
+	} \
+})
+#define JSONOBJECT12(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 12, \
+	.keys = (char *[12]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12) \
+	}, \
+	.values = (struct json_value[12]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12) \
+	} \
+})
+#define JSONOBJECT13(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 13, \
+	.keys = (char *[13]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13) \
+	}, \
+	.values = (struct json_value[13]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13) \
+	} \
+})
+#define JSONOBJECT14(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 14, \
+	.keys = (char *[14]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14) \
+	}, \
+	.values = (struct json_value[14]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14) \
+	} \
+})
+#define JSONOBJECT15(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 15, \
+	.keys = (char *[15]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15) \
+	}, \
+	.values = (struct json_value[15]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15) \
+	} \
+})
+#define JSONOBJECT16(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 16, \
+	.keys = (char *[16]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16) \
+	}, \
+	.values = (struct json_value[16]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16) \
+	} \
+})
+#define JSONOBJECT17(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 17, \
+	.keys = (char *[17]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17) \
+	}, \
+	.values = (struct json_value[17]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17) \
+	} \
+})
+#define JSONOBJECT18(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17, key18, val18) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 18, \
+	.keys = (char *[18]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17), (key18) \
+	}, \
+	.values = (struct json_value[18]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17), (val18) \
+	} \
+})
+#define JSONOBJECT19(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17, key18, val18, key19, val19) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 19, \
+	.keys = (char *[19]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17), (key18), (key19) \
+	}, \
+	.values = (struct json_value[19]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17), (val18), (val19) \
+	} \
+})
+#define JSONOBJECT20(key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, key16, val16, key17, val17, key18, val18, key19, val19, key20, val20) ((struct json_value) { \
+	.type = kJsonObject, \
+	.size = 20, \
+	.keys = (char *[20]) { \
+		(key1), (key2), (key3), (key4), (key5), (key6), (key7), (key8), (key9), (key10), (key11), (key12), (key13), (key14), (key15), (key16), (key17), (key18), (key19), (key20) \
+	}, \
+	.values = (struct json_value[20]) { \
+		(val1), (val2), (val3), (val4), (val5), (val6), (val7), (val8), (val9), (val10), (val11), (val12), (val13), (val14), (val15), (val16), (val17), (val18), (val19), (val20) \
+	} \
+})
+
+/// codec of an abstract channel object
+/// These tell this API how it should encode ChannelObjects -> platform messages
+/// and how to decode platform messages -> ChannelObjects.
+enum platch_codec {
+    kNotImplemented,
+    kStringCodec,
+    kBinaryCodec,
+    kJSONMessageCodec,
+    kStandardMessageCodec,
+    kStandardMethodCall,
+    kStandardMethodCallResponse,
+    kJSONMethodCall,
+    kJSONMethodCallResponse
+};
+
+/// Platform Channel Object.
+/// Different properties are "valid" for different codecs:
+///   kNotImplemented:
+///     no values associated with this "codec".
+///     this represents a platform message with no buffer and zero length. (so just an empty response)
+///   kStringCodec:
+///     - string_value is the raw byte data of a platform message, but with an additional null-byte at the end.
+///   kBinaryCodec:
+///     - binarydata is an array of the raw byte data of a platform message,
+///     - binarydata_size is the size of that byte data in bytes.
+///   kJSONMessageCodec:
+///     - json_value
+///   kStandardMessageCodec:
+///     - std_value
+///   kStandardMethodCall:
+///     - "method" is the method you'd like to call, or the method that was called
+///       by flutter.
+///     - std_arg contains the argument to that method call.
+///   kJSONMethodCall:
+///     - "method" is the method you'd like to call, or the method that was called
+///       by flutter.
+///     - json_arg contains the argument to that method call.
+///   kStandardMethodCallResponse or kJSONMethodCallResponse:
+///     - "success" is whether the method call (called by flutter or by called by you)
+///       if success is false,
+///         - error_code must be set to point to a valid null-terminated string,
+///         - error_msg is either pointing to a valid null-terminated string or is set to NULL,
+///         - if the codec is kStandardMethodCallResponse,
+///             std_error_details must be a valid std_value
+///             ({.type = kStdNull} is possible, but not NULL).
+///         - if the codec is kJSONMethodCallResponse,
+///             json_error_details must be a valid json_value
+///             ({.type = kJsonNull} is possible, but not NULL)
+struct platch_obj {
+    enum platch_codec codec;
+    union {
+        char                    *string_value;
+        struct {
+            size_t   binarydata_size;
+            uint8_t *binarydata;
+        };
+        struct json_value json_value;
+        struct std_value  std_value;
+        struct {
+            char *method;
+            union {
+                struct std_value  std_arg;
+                struct json_value json_arg;
+            };
+        };
+        struct {
+            bool success;
+            union {
+                struct std_value  std_result;
+                struct json_value json_result;
+            };
+            char *error_code;
+            char *error_msg;
+            union {
+                struct std_value std_error_details;
+                struct json_value json_error_details;
+            };
+        };
+    };
+};
+
+#define PLATCH_OBJ_NOT_IMPLEMENTED ((struct platch_obj) {.codec = kNotImplemented})
+#define PLATCH_OBJ_STRING(string) ((struct platch_obj) {.codec = kStringCodec, .string_value = (string)})
+#define PLATCH_OBJ_BINARY_DATA(data, data_size) ((struct platch_obj) {.codec = kBinaryCodec, .binarydata_size = (data_size), .binarydata = (data)})
+#define PLATCH_OBJ_JSON_MSG(__json_value) ((struct platch_obj) {.codec = kJSONMessageCodec, .json_value = (__json_value)})
+#define PLATCH_OBJ_STD_MSG(__std_value) ((struct platch_obj) {.codec = kStandardMessageCodec, .std_value = (__std_value)})
+#define PLATCH_OBJ_STD_CALL(method_name, arg) ((struct platch_obj) {.codec = kStandardMethodCall, .method = (char*) (method_name), .std_arg = (arg)})
+#define PLATCH_OBJ_JSON_CALL(method_name, arg) ((struct platch_obj) {.codec = kJSONMethodCall, .method = (char*) (method_name), .json_arg = (arg)})
+#define PLATCH_OBJ_STD_CALL_SUCCESS_RESPONSE(result) ((struct platch_obj) {.codec = kStandardMethodCallResponse, .success = true, .std_result = (result)})
+#define PLATCH_OBJ_STD_CALL_ERROR_RESPONSE(code, msg, details) ((struct platch_obj) {.codec = kStandardMethodCallResponse, .success = false, .error_code = (char*) (code), .error_msg = (char*) (msg), .std_error_details = (details)})
+#define PLATCH_OBJ_JSON_CALL_SUCCESS_RESPONSE(result) ((struct platch_obj) {.codec = kJSONMethodCallResponse, .success = true, .json_result = (result)})
+#define PLATCH_OBJ_JSON_CALL_ERROR_RESPONSE(code, msg, details) ((struct platch_obj) {.codec = kStandardMethodCallResponse, .success = false, .error_code = (char*) (code), .error_msg = (char*) (msg), .json_error_details = (details)})
+#define PLATCH_OBJ_STD_SUCCESS_EVENT(value) PLATCH_OBJ_STD_CALL_SUCCESS_RESPONSE(value)
+#define PLATCH_OBJ_STD_ERROR_EVENT(code, msg, details) PLATCH_OBJ_STD_CALL_ERROR_RESPONSE(code, msg, details)
+#define PLATCH_OBJ_JSON_SUCCESS_EVENT(value) PLATCH_OBJ_JSON_CALL_SUCCESS_RESPONSE(value)
+#define PLATCH_OBJ_JSON_ERROR_EVENT(code, msg, details) PLATCH_OBJ_JSON_CALL_ERROR_RESPONSE(code, msg, details)
+
+/// A Callback that is called when a response to a platform message you send to flutter
+/// arrives. "object" is the platform message decoded using the "codec" you gave to PlatformChannel_send,
+/// "userdata" is the userdata you gave to PlatformChannel_send.
+typedef int (*platch_msg_resp_callback)(struct platch_obj *object, void *userdata);
+
+
+/// decodes a platform message (represented by `buffer` and `size`) as the given codec,
+/// and puts the result into object_out.
+/// This method will (in some cases) dynamically allocate memory,
+/// so you should always call PlatformChannel_free(object_out) when you don't need it anymore.
+/// 
+/// Additionally, PlatformChannel_decode currently "borrows" from the buffer, so if the buffer
+/// is freed by flutter, the contents of object_out will in many cases be bogus.
+/// If you'd like object_out to be persistent and not depend on the lifetime of the buffer,
+/// you'd have to manually deep-copy it.
+int platch_decode(uint8_t *buffer, size_t size, enum platch_codec codec, struct platch_obj *object_out);
+
+/// Encodes a generic ChannelObject into a buffer (that is, too, allocated by PlatformChannel_encode)
+/// A pointer to the buffer is put into buffer_out and the size of that buffer into size_out.
+/// The lifetime of the buffer is independent of the ChannelObject, so contents of the ChannelObject
+///   can be freed after the object was encoded.
+int platch_encode(struct platch_obj *object, uint8_t **buffer_out, size_t *size_out);
+
+/// Encodes a generic ChannelObject (anything, string/binary codec or Standard/JSON Method Calls and responses) as a platform message
+/// and sends it to flutter on channel `channel`
+/// If you supply a response callback (i.e. on_response is != NULL):
+///   when flutter responds to this message, it is automatically decoded using the codec given in `response_codec`.
+///   Then, on_response is called with the decoded ChannelObject and the userdata as an argument.
+///   It's possible that flutter won't respond to your platform message, like when sending events via an EventChannel.
+/// userdata can be NULL.
+int platch_send(struct fwr_instance *instance,
+				char *channel,
+                struct platch_obj *object,
+                enum platch_codec response_codec,
+                platch_msg_resp_callback on_response,
+                void *userdata);
+
+/// Encodes a StandardMethodCodec method call as a platform message and sends it to flutter
+/// on channel `channel`. This is just a wrapper around PlatformChannel_send
+/// that builds the ChannelObject for you.
+/// The response_codec is kStandardMethodCallResponse. userdata can be NULL.
+int platch_call_std(struct fwr_instance *instance,
+					char *channel,
+                    char *method,
+                    struct std_value *argument,
+                    platch_msg_resp_callback on_response,
+                    void *userdata);
+
+/// Encodes the arguments as a JSON method call and sends it to flutter
+/// on channel [channel]. This is just a wrapper around platch_send
+/// that builds the ChannelObject for you.
+/// The response is automatically decoded as a JSON method call response and
+/// supplied to [on_response] as an argument. userdata can be NULL.
+int platch_call_json(struct fwr_instance *instance,
+					char *channel,
+                     char *method,
+                     struct json_value *argument,
+                     platch_msg_resp_callback on_response,
+                     void *userdata);
+
+/// Responds to a platform message. You can (of course) only respond once to a platform message,
+/// i.e. a FlutterPlatformMessageResponseHandle can only be used once.
+/// The codec of `response` can be any of the available codecs.
+int platch_respond(struct fwr_instance *instance,
+					FlutterPlatformMessageResponseHandle *handle,
+                   struct platch_obj *response);
+
+/// Tells flutter that the platform message that was sent to you was not handled.
+///   (for example, there's no plugin that is using this channel, or there is a plugin
+///   but it doesn't want to respond.)
+/// You should always use this instead of not replying to a platform message, since not replying could cause a memory leak.
+/// When flutter receives this response, it will throw a MissingPluginException.
+///   For most channel used by the ServicesPlugin, this is not too bad since it
+///   specifies many of the channels used as OptionalMethodChannels. (which will silently catch the MissingPluginException)
+int platch_respond_not_implemented(struct fwr_instance *instance, FlutterPlatformMessageResponseHandle *handle);
+
+int platch_respond_success_std(struct fwr_instance *instance,
+							   FlutterPlatformMessageResponseHandle *handle,
+							   struct std_value *return_value);
+
+int platch_respond_error_std(struct fwr_instance *instance,
+							 FlutterPlatformMessageResponseHandle *handle,
+							 char *error_code,
+							 char *error_msg,
+							 struct std_value *error_details);
+
+int platch_respond_illegal_arg_std(struct fwr_instance *instance,
+								   FlutterPlatformMessageResponseHandle *handle,
+								   char *error_msg);
+
+int platch_respond_native_error_std(struct fwr_instance *instance,
+									FlutterPlatformMessageResponseHandle *handle,
+									int _errno);
+
+
+int platch_respond_success_json(struct fwr_instance *instance,
+								FlutterPlatformMessageResponseHandle *handle,
+								struct json_value *return_value);
+
+int platch_respond_error_json(struct fwr_instance *instance,
+							  FlutterPlatformMessageResponseHandle *handle,
+							  char *error_code,
+							  char *error_msg,
+							  struct json_value *error_details);
+
+int platch_respond_illegal_arg_json(struct fwr_instance *instance,
+									FlutterPlatformMessageResponseHandle *handle,
+                                    char *error_msg);
+
+int platch_respond_native_error_json(struct fwr_instance *instance,
+									 FlutterPlatformMessageResponseHandle *handle,
+                                     int _errno);
+
+int platch_respond_success_pigeon(
+	struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	struct std_value *return_value
+);
+
+int platch_respond_error_pigeon(
+	struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	char *error_code,
+	char *error_msg,
+	struct std_value *error_details
+);
+
+int platch_respond_illegal_arg_pigeon(
+	struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	char *error_msg
+);
+
+int platch_respond_illegal_arg_ext_pigeon(
+	struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	char *error_msg,
+	struct std_value *error_details
+);
+
+int platch_respond_native_error_pigeon(
+	struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	int _errno
+);
+
+/// Sends a success event with value `event_value` to an event channel
+/// that uses the standard method codec.                                 
+int platch_send_success_event_std(struct fwr_instance *instance,
+								  char *channel,
+                                  struct std_value *event_value);
+
+/// Sends an error event to an event channel that uses the standard method codec.
+int platch_send_error_event_std(struct fwr_instance *instance,
+								char *channel,
+							 	char *error_code,
+							 	char *error_msg,
+							 	struct std_value *error_details);
+/// Sends a success event with value `event_value` to an event channel
+/// that uses the JSON method codec.
+int platch_send_success_event_json(struct fwr_instance *instance,
+								   char *channel,
+                                   struct json_value *event_value);
+
+/// Sends an error event to an event channel that uses the JSON method codec.
+int platch_send_error_event_json(struct fwr_instance *instance,
+								 char *channel,
+								 char *error_code,
+								 char *error_msg,
+								 struct json_value *error_details);
+
+/// frees a ChannelObject that was decoded using PlatformChannel_decode.
+/// not freeing ChannelObjects may result in a memory leak.
+int platch_free_obj(struct platch_obj *object);
+
+int platch_free_json_value(struct json_value *value, bool shallow);
+
+/// returns true if values a and b are equal.
+/// for JS arrays, the order of the values is relevant
+/// (so two arrays are only equal if the same values appear in exactly same order)
+/// for objects, the order of the entries is irrelevant.
+bool jsvalue_equals(struct json_value *a, struct json_value *b);
+
+/// given a JS object as an argument, it searches for an entry with key "key"
+/// and returns the value associated with it.
+/// if the key is not found, returns NULL.
+struct json_value *jsobject_get(struct json_value *object, char *key);
+
+/// StdMsgCodecValue equivalent of jsvalue_equals.
+/// again, for lists, the order of values is relevant
+/// for maps, it's not.
+bool stdvalue_equals(struct std_value *a, struct std_value *b);
+
+/// StdMsgCodecValue equivalent of jsobject_get, just that the key can be
+/// any arbitrary StdMsgCodecValue (and must not be a string as for jsobject_get)
+struct std_value *stdmap_get(struct std_value *map, struct std_value *key);
+
+struct std_value *stdmap_get_str(struct std_value *map, char *key);
+
+#endif
\ No newline at end of file
diff --git a/src/flutter_wlroots.c b/src/flutter_wlroots.c
index ef54853..087662e 100644
--- a/src/flutter_wlroots.c
+++ b/src/flutter_wlroots.c
@@ -131,25 +131,24 @@ static void engine_cb_platform_message(
 
   struct dart_value name = {};
   struct dart_value args = {};
+  size_t offset = 0;
 
-  if (strcmp(engine_message->channel, "wlroots") == 0) {
-    size_t offset = 0;
-
-    if (!message_read(engine_message->message, engine_message->message_size, &offset, &name)) {
-      wlr_log(WLR_ERROR, "Error decoding platform message name");
-      goto error;
-    }
+  if (!message_read(engine_message->message, engine_message->message_size, &offset, &name)) {
+    wlr_log(WLR_ERROR, "Error decoding platform message name");
+    goto error;
+  }
 
-    if (!message_read(engine_message->message, engine_message->message_size, &offset, &args)) {
-      wlr_log(WLR_ERROR, "Error decoding platform message args");
-      goto error;
-    }
+  if (!message_read(engine_message->message, engine_message->message_size, &offset, &args)) {
+    wlr_log(WLR_ERROR, "Error decoding platform message args");
+    goto error;
+  }
 
-    if (name.type != dvString) {
-      goto error;
-    }
-    const char *method_name = name.string.string;
+  if (name.type != dvString) {
+    goto error;
+  }
+  const char *method_name = name.string.string;
 
+  if (strcmp(engine_message->channel, "wlroots") == 0) {
     if (strcmp(method_name, "surface_pointer_event") == 0) {
       fwr_handle_surface_pointer_event_message(instance, engine_message->response_handle, &args);
       return;
@@ -165,7 +164,7 @@ static void engine_cb_platform_message(
 
 error:
   // TODO(hansihe): Handle messages
-  wlr_log(WLR_INFO, "Unhandled platform message: channel: %s", engine_message->channel);
+  wlr_log(WLR_INFO, "Unhandled platform message: channel: %s; name: %s", engine_message->channel, method_name);
 
   message_free(&name);
   message_free(&args);
diff --git a/src/input.c b/src/input.c
index 67f1e24..6a0819e 100644
--- a/src/input.c
+++ b/src/input.c
@@ -24,6 +24,7 @@
 #include "constants.h"
 #include "handle_map.h"
 #include "messages.h"
+#include "platform_channel.h"
 
 #define NS_PER_MS 1000000
 
@@ -562,38 +563,12 @@ static uint64_t apply_id_plane(uint64_t logical_id, uint64_t plane) {
   return (logical_id & kValueMask) | plane;
 }
 
-static void send_key_to_flutter(struct fwr_keyboard *keyboard, struct wlr_event_keyboard_key *event, FlutterKeyEventType key_event_type) {
+static void send_key_to_flutter(struct fwr_keyboard *keyboard, struct wlr_event_keyboard_key *event) {
   struct fwr_instance *instance = keyboard->instance;
-  /* struct message_builder msg = message_builder_new();
-  struct message_builder_segment msg_seg = message_builder_segment(&msg);
-  message_builder_segment_push_string(&msg_seg, "flutter/keyevent");
-  message_builder_segment_finish(&msg_seg);
-
-  msg_seg = message_builder_segment(&msg);
-  struct message_builder_segment arg_seg = message_builder_segment_push_map(&msg_seg, 3);
-  message_builder_segment_push_string(&arg_seg, "keymap");
-  message_builder_segment_push_string(&arg_seg, "wlroots");
-  message_builder_segment_push_string(&arg_seg, "keyCode");
-  message_builder_segment_push_int64(&arg_seg, event->keycode);
-  message_builder_segment_push_string(&arg_seg, "type");
-  message_builder_segment_push_string(&arg_seg, key_event_type);
-  message_builder_segment_finish(&arg_seg);
-
-  message_builder_segment_finish(&msg_seg);
-  uint8_t *msg_buf;
-  size_t msg_buf_len;
-  message_builder_finish(&msg, &msg_buf, &msg_buf_len); */
 
   FlutterPlatformMessageResponseHandle *response_handle;
   instance->fl_proc_table.PlatformMessageCreateResponseHandle(instance->engine, cb, NULL, &response_handle);
 
-  /* FlutterPlatformMessage platform_message = {};
-  platform_message.struct_size = sizeof(FlutterPlatformMessage);
-  platform_message.channel = "wlroots";
-  platform_message.message = msg_buf;
-  platform_message.message_size = msg_buf_len;
-  platform_message.response_handle = response_handle; */
-
 	uint32_t keycode = event->keycode + 8;
   xkb_keysym_t codepoint = xkb_state_key_get_one_sym(
       keyboard->device->keyboard->xkb_state, keycode);
@@ -611,15 +586,63 @@ static void send_key_to_flutter(struct fwr_keyboard *keyboard, struct wlr_event_
 
   wlr_log(WLR_INFO, "%d", keycode);
 
+  char *type;
+  FlutterKeyEventType flType;
+
+  switch(event->state) {
+    case WL_KEYBOARD_KEY_STATE_PRESSED:
+      type = "keydown";
+      flType = kFlutterKeyEventTypeDown;
+      break;
+    case WL_KEYBOARD_KEY_STATE_RELEASED:
+    default:
+      type = "keyup";
+      flType = kFlutterKeyEventTypeUp;
+      break;
+  }
+
   FlutterKeyEvent key_event = {};
   key_event.struct_size = sizeof(FlutterKeyEvent);
-  key_event.type = key_event_type;
+  key_event.type = flType;
   key_event.physical = 0x00070004;//codepoint;
   key_event.logical = apply_id_plane(0x041, kUnicodePlane);//65;
-  key_event.character = key_event_type == kFlutterKeyEventTypeDown ? buffer : NULL;
+  key_event.character = flType == kFlutterKeyEventTypeDown ? buffer : NULL;
   key_event.timestamp = instance->fl_proc_table.GetCurrentTime();
   key_event.synthesized = false;
   instance->fl_proc_table.SendKeyEvent(instance->engine, &key_event, cb, response_handle);
+
+  platch_send(
+    instance,
+    "flutter/keyevent",
+    &(struct platch_obj) {
+      .codec = kJSONMessageCodec,
+      .json_value = {
+        .type = kJsonObject,
+        .size = 7,
+        .keys = (char*[7]) {
+          "keymap",
+          "toolkit",
+          "unicodeScalarValues",
+          "keyCode",
+          "scanCode",
+          "modifiers",
+          "type"
+        },
+        .values = (struct json_value[7]) {
+          /* keymap */                {.type = kJsonString, .string_value = "linux"},
+          /* toolkit */               {.type = kJsonString, .string_value = "gtk"},
+          /* unicodeScalarValues */   {.type = kJsonNumber, .number_value = (flType == kFlutterKeyEventTypeDown ? 0x0410 : 0x0)},
+          /* keyCode */               {.type = kJsonNumber, .number_value = apply_id_plane(0x041, kUnicodePlane)},
+          /* scanCode */              {.type = kJsonNumber, .number_value = 0x00070004},
+          /* modifiers */             {.type = kJsonNumber, .number_value = 0x0},
+          /* type */                  {.type = kJsonString, .string_value = type}
+        }
+      }
+    },
+    kJSONMessageCodec,
+    NULL,
+    NULL
+  );
   //instance->fl_proc_table.SendPlatformMessage(instance->engine, &platform_message);
 }
 
@@ -660,19 +683,8 @@ static void keyboard_handle_key(
   int nsyms = xkb_state_key_get_syms(keyboard->device->keyboard->xkb_state, keycode, &syms); */
 
   //bool handled = false;
-  FlutterKeyEventType type;
-
-  switch(event->state) {
-    case WL_KEYBOARD_KEY_STATE_PRESSED:
-      type = kFlutterKeyEventTypeDown;
-      break;
-    case WL_KEYBOARD_KEY_STATE_RELEASED:
-    default:
-      type = kFlutterKeyEventTypeUp;
-      break;
-  }
 
-  send_key_to_flutter(keyboard, event, type);
+  send_key_to_flutter(keyboard, event);
   //send_key_to_flutter(keyboard, event, kFlutterKeyEventTypeUp);
 
   // uint32_t modifiers = wlr_keyboard_get_modifiers(keyboard->device->keyboard);
diff --git a/src/meson.build b/src/meson.build
index dc6e742..fb072e5 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -8,5 +8,6 @@ fwr_src += files(
     'handle_map.cc',
     'messages.c',
     'output.c',
+    'platform_channel.c',
     'surface.c',
 )
diff --git a/src/platform_channel.c b/src/platform_channel.c
new file mode 100644
index 0000000..1d43395
--- /dev/null
+++ b/src/platform_channel.c
@@ -0,0 +1,1765 @@
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <flutter_embedder.h>
+
+#include "instance.h"
+#include "platform_channel.h"
+/* #include <flutter-pi.h> */
+#include <jsmn.h>
+
+
+struct platch_msg_resp_handler_data {
+	enum platch_codec codec;
+	platch_msg_resp_callback on_response;
+	void *userdata;
+};
+
+
+static int _check_remaining(size_t *remaining, int min_remaining) {
+	if (remaining == NULL) {
+		return 0;
+	}
+	if (*remaining < min_remaining) {
+		return EBADMSG;
+	}
+	return 0;
+}
+static int _read(uint8_t **pbuffer, void *dest, int n_bytes, size_t *remaining) {
+	int ok;
+
+	ok = _check_remaining(remaining, n_bytes);
+	if (ok != 0) {
+		return ok;
+	}
+
+	memcpy(dest, *pbuffer, (size_t) n_bytes);
+	if (remaining != NULL) {
+		*remaining -= n_bytes;
+	}
+	*pbuffer += n_bytes;
+	return 0;
+}
+static int _write(uint8_t **pbuffer, void *src, int n_bytes, size_t *remaining) {
+	int ok;
+
+	ok = _check_remaining(remaining, n_bytes);
+	if (ok != 0) {
+		return ok;
+	}
+
+	memcpy(*pbuffer, src, (size_t) n_bytes);
+	if (remaining != NULL) {
+		*remaining -= n_bytes;
+	}
+	*pbuffer += n_bytes;
+	return 0;
+}
+
+static int _advance(uintptr_t *value, int n_bytes, size_t *remaining) {
+	int ok;
+
+	ok = _check_remaining(remaining, n_bytes);
+	if (ok != 0) {
+		return ok;
+	}
+
+	if (remaining != NULL) {
+    	*remaining -= n_bytes;
+	}
+    *value += n_bytes;
+    return 0;
+}
+static int _align(uintptr_t *value, int alignment, size_t *remaining) {
+    int diff;
+
+    alignment--;
+	diff = ((((*value) + alignment) | alignment) - alignment) - *value;
+
+    return _advance(value, diff, remaining);
+}
+static int _advance_size_bytes(uintptr_t *value, size_t size, size_t *remaining) {
+    if (size < 254) {
+		return _advance(value, 1, remaining);
+	} else if (size <= 0xFFFF) {
+		return _advance(value, 3, remaining);
+	} else {
+		return _advance(value, 5, remaining);
+    }
+}
+
+#define DEFINE_READ_WRITE_FUNC(suffix, value_type) \
+static int _write_##suffix(uint8_t **pbuffer, value_type value, size_t *remaining) { \
+	return _write(pbuffer, &value, sizeof value, remaining); \
+} \
+static int _read_##suffix(uint8_t **pbuffer, value_type* value, size_t *remaining) { \
+	return _read(pbuffer, value, sizeof *value, remaining); \
+}
+
+DEFINE_READ_WRITE_FUNC(    u8,  uint8_t)
+DEFINE_READ_WRITE_FUNC(   u16, uint16_t)
+DEFINE_READ_WRITE_FUNC(   u32, uint32_t)
+DEFINE_READ_WRITE_FUNC(   u64, uint64_t)
+DEFINE_READ_WRITE_FUNC(    i8,   int8_t)
+DEFINE_READ_WRITE_FUNC(   i16,  int16_t)
+DEFINE_READ_WRITE_FUNC(   i32,  int32_t)
+DEFINE_READ_WRITE_FUNC(   i64,  int64_t)
+DEFINE_READ_WRITE_FUNC( float,    float)
+DEFINE_READ_WRITE_FUNC(double,   double)
+
+static int _writeSize(uint8_t **pbuffer, int size, size_t *remaining) {
+	int ok;
+
+    if (size < 254) {
+		return _write_u8(pbuffer, (uint8_t) size, remaining);
+	} else if (size <= 0xFFFF) {
+		ok = _write_u8(pbuffer, 0xFE, remaining);
+        if (ok != 0) return ok;
+
+		ok = _write_u16(pbuffer, (uint16_t) size, remaining);
+        if (ok != 0) return ok;
+	} else {
+		ok = _write_u8(pbuffer, 0xFF, remaining);
+        if (ok != 0) return ok;
+
+		ok = _write_u32(pbuffer, (uint32_t) size, remaining);
+        if (ok != 0) return ok;
+    }
+
+    return ok;
+}
+static int _readSize(uint8_t **pbuffer, uint32_t *psize, size_t *remaining) {
+	int ok;
+    uint8_t size8;
+    uint16_t size16;
+
+	ok = _read_u8(pbuffer, &size8, remaining);
+    if (ok != 0) return ok;
+    
+    if (size8 <= 253) {
+        *psize = size8;
+
+        return 0;
+    } else if (size8 == 254) {
+		ok = _read_u16(pbuffer, &size16, remaining);
+        if (ok != 0) return ok;
+
+        *psize = size16;
+        return 0;
+	} else if (size8 == 255) {
+		return _read_u32(pbuffer, psize, remaining);
+	}
+
+    return 0;
+}
+
+
+int platch_free_value_std(struct std_value *value) {
+	int ok;
+
+	switch (value->type) {
+		case kStdString:
+			free(value->string_value);
+			break;
+		case kStdList:
+			for (int i=0; i < value->size; i++) {
+				ok = platch_free_value_std(&(value->list[i]));
+				if (ok != 0) return ok;
+			}
+			free(value->list);
+			break;
+		case kStdMap:
+			for (int i=0; i < value->size; i++) {
+				ok = platch_free_value_std(&(value->keys[i]));
+				if (ok != 0) return ok;
+				ok = platch_free_value_std(&(value->values[i]));
+				if (ok != 0) return ok;
+			}
+			free(value->keys);
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+int platch_free_json_value(struct json_value *value, bool shallow) {
+	int ok;
+	
+	switch (value->type) {
+		case kJsonArray:
+			if (!shallow) {
+				for (int i = 0; i < value->size; i++) {
+					ok = platch_free_json_value(&(value->array[i]), false);
+					if (ok != 0) return ok;
+				}
+			}
+
+			free(value->array);
+			break;
+		case kJsonObject:
+			if (!shallow) {
+				for (int i = 0; i < value->size; i++) {
+					ok = platch_free_json_value(&(value->values[i]), false);
+					if (ok != 0) return ok;
+				}
+			}
+
+			free(value->keys);
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+int platch_free_obj(struct platch_obj *object) {
+	switch (object->codec) {
+		case kStringCodec:
+			free(object->string_value);
+			break;
+		case kBinaryCodec:
+			break;
+		case kJSONMessageCodec:
+			platch_free_json_value(&(object->json_value), false);
+			break;
+		case kStandardMessageCodec:
+			platch_free_value_std(&(object->std_value));
+			break;
+		case kStandardMethodCall:
+			free(object->method);
+			platch_free_value_std(&(object->std_arg));
+			break;
+		case kJSONMethodCall:
+			platch_free_json_value(&(object->json_arg), false);
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+int platch_calc_value_size_std(struct std_value* value, size_t* size_out) {
+	enum std_value_type type = value->type;
+	uintptr_t size = (uintptr_t) *size_out;
+	size_t element_size, sizet_size = 0;
+	int ok;
+
+	// Type Byte
+	_advance(&size, 1, NULL);
+	switch (type) {
+		case kStdNull:
+		case kStdTrue:
+		case kStdFalse:
+			break;
+		case kStdInt32:
+			_advance(&size, 4, NULL);
+			break;
+		case kStdInt64:
+			_advance(&size, 8, NULL);
+			break;
+		case kStdFloat64:
+			_align  (&size, 8, NULL);
+			_advance(&size, 8, NULL);
+			break;
+		case kStdString:
+		case kStdLargeInt:
+			element_size = strlen(value->string_value);
+			_advance_size_bytes(&size, element_size, NULL);
+			_advance(&size, element_size, NULL);
+			break;
+		case kStdUInt8Array:
+			element_size = value->size;
+			_advance_size_bytes(&size, element_size, NULL);
+			_advance(&size, element_size, NULL);
+			break;
+		case kStdInt32Array:
+			element_size = value->size;
+
+			_advance_size_bytes(&size, element_size, NULL);
+			_align  (&size, 4, NULL);
+			_advance(&size, element_size*4, NULL);
+
+			break;
+		case kStdInt64Array:
+			element_size = value->size;
+			
+			_advance_size_bytes(&size, element_size, NULL);
+			_align  (&size, 8, NULL);
+			_advance(&size, element_size*8, NULL);
+
+			break;
+		case kStdFloat64Array:
+			element_size = value->size;
+			
+			_advance_size_bytes(&size, element_size, NULL);
+			_align  (&size, 8, NULL);
+			_advance(&size, element_size*8, NULL);
+
+			break;
+		case kStdList:
+			element_size = value->size;
+
+			_advance_size_bytes(&size, element_size, NULL);
+			for (int i = 0; i<element_size; i++) {
+				sizet_size = (size_t) size;
+
+				ok = platch_calc_value_size_std(&(value->list[i]), &sizet_size);
+				if (ok != 0) return ok;
+
+				size = (uintptr_t) sizet_size;
+			}
+
+			break;
+		case kStdMap:
+			element_size = value->size;
+
+			_advance_size_bytes(&size, element_size, NULL);
+			for (int i = 0; i<element_size; i++) {
+				sizet_size = (size_t) size;
+
+				ok = platch_calc_value_size_std(&(value->keys[i]), &sizet_size);
+				if (ok != 0) return ok;
+
+				ok = platch_calc_value_size_std(&(value->values[i]), &sizet_size);
+				if (ok != 0) return ok;
+
+				size = (uintptr_t) sizet_size;
+			}
+
+			break;
+		default:
+			return EINVAL;
+	}
+
+	*size_out = (size_t) size;
+
+	return 0;
+}
+int platch_write_value_to_buffer_std(struct std_value* value, uint8_t **pbuffer) {
+	uint8_t* byteArray;
+	size_t size;
+	int ok;
+
+	_write_u8(pbuffer, value->type, NULL);
+
+	switch (value->type) {
+		case kStdNull:
+		case kStdTrue:
+		case kStdFalse:
+			break;
+		case kStdInt32:
+			_write_i32(pbuffer, value->int32_value, NULL);
+			break;
+		case kStdInt64:
+			_write_i64(pbuffer, value->int64_value, NULL);
+			break;
+		case kStdFloat64:
+			_align  ((uintptr_t*) pbuffer, 8, NULL);
+			_write_double(pbuffer, value->float64_value, NULL);
+			break;
+		case kStdLargeInt:
+		case kStdString:
+		case kStdUInt8Array:
+			if ((value->type == kStdLargeInt) || (value->type == kStdString)) {
+				size = strlen(value->string_value);
+				byteArray = (uint8_t*) value->string_value;
+			} else {
+				DEBUG_ASSERT(value->type == kStdUInt8Array);
+				size = value->size;
+				byteArray = value->uint8array;
+			}
+
+			_writeSize(pbuffer, size, NULL);
+			for (int i=0; i<size; i++) {
+				_write_u8(pbuffer, byteArray[i], NULL);
+			}
+			break;
+		case kStdInt32Array:
+			size = value->size;
+
+			_writeSize(pbuffer, size, NULL);
+			_align   ((uintptr_t*) pbuffer, 4, NULL);
+			
+			for (int i=0; i<size; i++) {
+				_write_i32(pbuffer, value->int32array[i], NULL);
+			}
+			break;
+		case kStdInt64Array:
+			size = value->size;
+
+			_writeSize(pbuffer, size, NULL);
+			_align((uintptr_t*) pbuffer, 8, NULL);
+			for (int i=0; i<size; i++) {
+				_write_i64(pbuffer, value->int64array[i], NULL);
+			}
+			break;
+		case kStdFloat64Array:
+			size = value->size;
+
+			_writeSize(pbuffer, size, NULL);
+			_align((uintptr_t*) pbuffer, 8, NULL);
+
+			for (int i=0; i<size; i++) {
+				_write_double(pbuffer, value->float64array[i], NULL);
+			}
+			break;
+		case kStdList:
+			size = value->size;
+
+			_writeSize(pbuffer, size, NULL);
+			for (int i=0; i < size; i++) {
+				ok = platch_write_value_to_buffer_std(&value->list[i], pbuffer);
+				if (ok != 0) return ok;
+			}
+
+			break;
+		case kStdMap:
+			size = value->size;
+
+			_writeSize(pbuffer, size, NULL);
+			for (int i=0; i<size; i++) {
+				ok = platch_write_value_to_buffer_std(&value->keys[i], pbuffer);
+				if (ok != 0) return ok;
+
+				ok = platch_write_value_to_buffer_std(&value->values[i], pbuffer);
+				if (ok != 0) return ok;
+			}
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+size_t platch_calc_value_size_json(struct json_value *value) {
+	size_t size = 0;
+
+	switch (value->type) {
+		case kJsonNull:
+		case kJsonTrue:
+			return 4;
+		case kJsonFalse:
+			return 5;
+		case kJsonNumber: ;
+			char numBuffer[32];
+			return sprintf(numBuffer, "%g", value->number_value);
+		case kJsonString:
+			size = 2;
+
+			// we need to count how many characters we need to escape.
+			for (char *s = value->string_value; *s; s++) {
+				switch (*s) {
+					case '\b':
+					case '\f':
+					case '\n':
+					case '\r':
+					case '\t':
+					case '\"':
+					case '\\':
+						size += 2;
+						break;
+					default:
+						size++;
+						break;
+				}
+			}
+
+			return size;
+		case kJsonArray:
+			size += 2;
+			for (int i=0; i < value->size; i++) {
+				size += platch_calc_value_size_json(value->array + i);
+				if (i+1 != value->size) size += 1;
+			}
+			return size;
+		case kJsonObject:
+			size += 2;
+			for (int i=0; i < value->size; i++) {
+				size += strlen(value->keys[i]) + 3 + platch_calc_value_size_json(&(value->values[i]));
+				if (i+1 != value->size) size += 1;
+			}
+			return size;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+int platch_write_value_to_buffer_json(struct json_value* value, uint8_t **pbuffer) {
+	switch (value->type) {
+		case kJsonNull:
+			*pbuffer += sprintf((char*) *pbuffer, "null");
+			break;
+		case kJsonTrue:
+			*pbuffer += sprintf((char*) *pbuffer, "true");
+			break;
+		case kJsonFalse:
+			*pbuffer += sprintf((char*) *pbuffer, "false");
+			break;
+		case kJsonNumber:
+			*pbuffer += sprintf((char*) *pbuffer, "%g", value->number_value);
+			break;
+		case kJsonString:
+			*((*pbuffer)++) = '\"';
+
+			for (char *s = value->string_value; *s; s++) {
+				switch (*s) {
+					case '\b':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = 'b';
+						break;
+					case '\f':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = 'f';
+						break;
+					case '\n':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = 'n';
+						break;
+					case '\r':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = 'r';
+						break;
+					case '\t':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = 't';
+						break;
+					case '\"':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = 't';
+						break;
+					case '\\':
+						*((*pbuffer)++) = '\\';
+						*((*pbuffer)++) = '\\';
+						break;
+					default:
+						*((*pbuffer)++) = *s;
+						break;
+				}
+			}
+
+			*((*pbuffer)++) = '\"';
+
+			break;
+		case kJsonArray:
+			*pbuffer += sprintf((char*) *pbuffer, "[");
+			for (int i=0; i < value->size; i++) {
+				platch_write_value_to_buffer_json(&(value->array[i]), pbuffer);
+				if (i+1 != value->size) *pbuffer += sprintf((char*) *pbuffer, ",");
+			}
+			*pbuffer += sprintf((char*) *pbuffer, "]");
+			break;	
+		case kJsonObject:
+			*pbuffer += sprintf((char*) *pbuffer, "{");
+			for (int i=0; i < value->size; i++) {
+				*pbuffer += sprintf((char*) *pbuffer, "\"%s\":", value->keys[i]);
+				platch_write_value_to_buffer_json(&(value->values[i]), pbuffer);
+				if (i+1 != value->size) *pbuffer += sprintf((char*) *pbuffer, ",");
+			}
+			*pbuffer += sprintf((char*) *pbuffer, "}");
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+int platch_decode_value_std(uint8_t **pbuffer, size_t *premaining, struct std_value *value_out) {
+	enum std_value_type type;
+	uint8_t type_byte;
+	uint32_t size;
+	int ok;
+
+	/// FIXME: Somehow, in release mode, this always reads 0.
+	ok = _read_u8(pbuffer, &type_byte, premaining);
+	if (ok != 0) return ok;
+
+	type = (enum std_value_type) type_byte;
+	value_out->type = (enum std_value_type) type_byte;
+	switch (type) {
+		case kStdNull:
+		case kStdTrue:
+		case kStdFalse:
+			break;
+		case kStdInt32:
+			ok = _read_i32(pbuffer, &value_out->int32_value, premaining);
+			if (ok != 0) return ok;
+
+			break;
+		case kStdInt64:
+			ok = _read_i64(pbuffer, &value_out->int64_value, premaining);
+			if (ok != 0) return ok;
+
+			break;
+		case kStdFloat64:
+			ok = _align((uintptr_t*) pbuffer, 8, premaining);
+			if (ok != 0) return ok;
+
+			ok = _read_double(pbuffer, &value_out->float64_value, premaining);
+			if (ok != 0) return ok;
+
+			break;
+		case kStdLargeInt:
+		case kStdString:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+
+			value_out->string_value = calloc(size+1, sizeof(char));
+			if (!value_out->string_value) return ENOMEM;
+
+			ok = _read(pbuffer, value_out->string_value, size, premaining);
+			if (ok != 0) {
+				free(value_out->string_value);
+				return ok;
+			}
+
+			break;
+		case kStdUInt8Array:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+			if (*premaining < size) return EBADMSG;
+
+			value_out->size = size;
+			value_out->uint8array = *pbuffer;
+
+			ok = _advance((uintptr_t*) pbuffer, size, premaining);
+			if (ok != 0) return ok;
+
+			break;
+		case kStdInt32Array:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+			
+			ok = _align((uintptr_t*) pbuffer, 4, premaining);
+			if (ok != 0) return ok;
+
+			if (*premaining < size*4) return EBADMSG;
+
+			value_out->size = size;
+			value_out->int32array = (int32_t*) *pbuffer;
+
+			ok = _advance((uintptr_t*) pbuffer, size*4, premaining);
+			if (ok != 0) return ok;
+
+			break;
+		case kStdInt64Array:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+
+			ok = _align((uintptr_t*) pbuffer, 8, premaining);
+			if (ok != 0) return ok;
+
+			if (*premaining < size*8) return EBADMSG;
+
+			value_out->size = size;
+			value_out->int64array = (int64_t*) *pbuffer;
+
+			ok = _advance((uintptr_t*) pbuffer, size*8, premaining);
+			if (ok != 0) return ok;
+
+			break;
+		case kStdFloat64Array:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+
+			ok = _align((uintptr_t*) pbuffer, 8, premaining);
+			if (ok != 0) return ok;
+
+			if (*premaining < size*8) return EBADMSG;
+
+			value_out->size = size;
+			value_out->float64array = (double*) *pbuffer;
+
+			ok = _advance((uintptr_t*) pbuffer, size*8, premaining);
+			if (ok != 0) return ok;
+			
+			break;
+		case kStdList:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+
+			value_out->size = size;
+			value_out->list = calloc(size, sizeof(struct std_value));
+
+			for (int i = 0; i < size; i++) {
+				ok = platch_decode_value_std(pbuffer, premaining, &value_out->list[i]);
+				if (ok != 0) return ok;
+			}
+
+			break;
+		case kStdMap:
+			ok = _readSize(pbuffer, &size, premaining);
+			if (ok != 0) return ok;
+
+			value_out->size = size;
+
+			value_out->keys = calloc(size*2, sizeof(struct std_value));
+			if (!value_out->keys) return ENOMEM;
+
+			value_out->values = &value_out->keys[size];
+
+			for (int i = 0; i < size; i++) {
+				ok = platch_decode_value_std(pbuffer, premaining, &(value_out->keys[i]));
+				if (ok != 0) return ok;
+				
+				ok = platch_decode_value_std(pbuffer, premaining, &(value_out->values[i]));
+				if (ok != 0) return ok;
+			}
+
+			break;
+		default:
+			return EBADMSG;
+	}
+
+	return 0;
+}
+int platch_decode_value_json(char *message, size_t size, jsmntok_t **pptoken, size_t *ptokensremaining, struct json_value *value_out) {
+	jsmntok_t *ptoken;
+	int result, ok;
+	
+	if (!pptoken) {
+		// if we have no token list yet, parse the message & create one.
+
+		jsmntok_t tokens[JSON_DECODE_TOKENLIST_SIZE];
+		jsmn_parser parser;
+		size_t tokensremaining;
+
+		memset(tokens, 0, sizeof(tokens));
+
+		jsmn_init(&parser);
+		result = jsmn_parse(&parser, (const char *) message, (const size_t) size, tokens, JSON_DECODE_TOKENLIST_SIZE);
+		if (result < 0) return EBADMSG;
+		
+		tokensremaining = (size_t) result;
+		ptoken = tokens;
+
+		ok = platch_decode_value_json(message, size, &ptoken, &tokensremaining, value_out);
+		if (ok != 0) return ok;
+	} else {
+		// message is already tokenized
+
+		ptoken = *pptoken;
+
+		(*pptoken) += 1;
+		*ptokensremaining -= 1;
+
+		switch (ptoken->type) {
+			case JSMN_UNDEFINED:
+				return EBADMSG;
+			case JSMN_PRIMITIVE:
+				if (message[ptoken->start] == 'n') {
+					value_out->type = kJsonNull;
+				} else if (message[ptoken->start] == 't') {
+					value_out->type = kJsonTrue;
+				} else if (message[ptoken->start] == 'f') {
+					value_out->type = kJsonFalse;
+				} else {
+					value_out->type = kJsonNumber;
+
+					// hacky, but should work in normal circumstances. If the platform message solely consists
+					//   of this number and nothing else, this could fail.
+					char old = message[ptoken->end];
+					message[ptoken->end] = '\0';
+					value_out->number_value = strtod(message + ptoken->start, NULL);
+					message[ptoken->end] = old;
+				}
+
+				break;
+			case JSMN_STRING: ;
+				// use zero-copy approach.
+
+				message[ptoken->end] = '\0';
+				char *string = message + ptoken->start;
+
+				value_out->type = kJsonString;
+				value_out->string_value = string;
+
+				break;
+			case JSMN_ARRAY: ;
+				struct json_value *array = calloc(ptoken->size, sizeof(struct json_value));
+				if (!array) return ENOMEM;
+
+				for (int i=0; i < ptoken->size; i++) {
+					ok = platch_decode_value_json(message, size, pptoken, ptokensremaining, &array[i]);
+					if (ok != 0) return ok;
+				}
+
+				value_out->type = kJsonArray;
+				value_out->size = ptoken->size;
+				value_out->array = array;
+
+				break;
+			case JSMN_OBJECT: ;
+				struct json_value  key;
+				char                    **keys = calloc(ptoken->size, sizeof(char *));
+				struct json_value *values = calloc(ptoken->size, sizeof(struct json_value));
+				if ((!keys) || (!values)) return ENOMEM;
+
+				for (int i=0; i < ptoken->size; i++) {
+					ok = platch_decode_value_json(message, size, pptoken, ptokensremaining, &key);
+					if (ok != 0) return ok;
+
+					if (key.type != kJsonString) return EBADMSG;
+					keys[i] = key.string_value;
+
+					ok = platch_decode_value_json(message, size, pptoken, ptokensremaining, &values[i]);
+					if (ok != 0) return ok;
+				}
+
+				value_out->type = kJsonObject;
+				value_out->size = ptoken->size;
+				value_out->keys = keys;
+				value_out->values = values;
+
+				break;
+			default:
+				return EBADMSG;
+		}
+	}
+
+	return 0;
+}
+
+int platch_decode_json(char *string, struct json_value *out) {
+	return platch_decode_value_json(string, strlen(string), NULL, NULL, out);
+}
+
+int platch_decode(uint8_t *buffer, size_t size, enum platch_codec codec, struct platch_obj *object_out) {
+	struct json_value root_jsvalue;
+	uint8_t *buffer_cursor = buffer;
+	size_t   remaining = size;
+	int      ok;
+
+	if ((size == 0) && (buffer == NULL)) {
+		object_out->codec = kNotImplemented;
+		return 0;
+	}
+	
+	object_out->codec = codec;
+	switch (codec) {
+		case kStringCodec: ;
+			/// buffer is a non-null-terminated, UTF8-encoded string.
+			/// it's really sad we have to allocate a new memory block for this, but we have to since string codec buffers are not null-terminated.
+
+			char *string;
+			if (!(string = malloc(size +1))) return ENOMEM;
+			memcpy(string, buffer, size);
+			string[size] = '\0';
+
+			object_out->string_value = string;
+
+			break;
+		case kBinaryCodec:
+			object_out->binarydata = buffer;
+			object_out->binarydata_size = size;
+
+			break;
+		case kJSONMessageCodec:
+			ok = platch_decode_value_json((char *) buffer, size, NULL, NULL, &(object_out->json_value));
+			if (ok != 0) return ok;
+
+			break;
+		case kJSONMethodCall: ;
+			ok = platch_decode_value_json((char *) buffer, size, NULL, NULL, &root_jsvalue);
+			if (ok != 0) return ok;
+
+			if (root_jsvalue.type != kJsonObject) return EBADMSG;
+			
+			for (int i=0; i < root_jsvalue.size; i++) {
+				if ((strcmp(root_jsvalue.keys[i], "method") == 0) && (root_jsvalue.values[i].type == kJsonString)) {
+					object_out->method = root_jsvalue.values[i].string_value;
+				} else if (strcmp(root_jsvalue.keys[i], "args") == 0) {
+					object_out->json_arg = root_jsvalue.values[i];
+				} else return EBADMSG;
+			}
+
+			platch_free_json_value(&root_jsvalue, true);
+
+			break;
+		case kJSONMethodCallResponse: ;
+			ok = platch_decode_value_json((char *) buffer, size, NULL, NULL, &root_jsvalue);
+			if (ok != 0) return ok;
+			if (root_jsvalue.type != kJsonArray) return EBADMSG;
+			
+			if (root_jsvalue.size == 1) {
+				object_out->success = true;
+				object_out->json_result = root_jsvalue.array[0];
+				return platch_free_json_value(&root_jsvalue, true);
+			} else if ((root_jsvalue.size == 3) &&
+					   (root_jsvalue.array[0].type == kJsonString) &&
+					   ((root_jsvalue.array[1].type == kJsonString) || (root_jsvalue.array[1].type == kJsonNull))) {
+				
+				
+				object_out->success = false;
+				object_out->error_code = root_jsvalue.array[0].string_value;
+				object_out->error_msg = root_jsvalue.array[1].string_value;
+				object_out->json_error_details = root_jsvalue.array[2];
+				return platch_free_json_value(&root_jsvalue, true);
+			} else return EBADMSG;
+
+			break;
+		case kStandardMessageCodec:
+			ok = platch_decode_value_std(&buffer_cursor, &remaining, &object_out->std_value);
+			if (ok != 0) return ok;
+			break;
+		case kStandardMethodCall: ;
+			struct std_value methodname;
+
+			ok = platch_decode_value_std(&buffer_cursor, &remaining, &methodname);
+			if (ok != 0) return ok;
+			if (methodname.type != kStdString) {
+				platch_free_value_std(&methodname);
+				return EBADMSG;
+			}
+			object_out->method = methodname.string_value;
+
+			ok = platch_decode_value_std(&buffer_cursor, &remaining, &object_out->std_arg);
+			if (ok != 0) return ok;
+
+			break;
+		case kStandardMethodCallResponse: ;
+			ok = _read_u8(&buffer_cursor, (uint8_t*) &object_out->success, &remaining);
+
+			if (object_out->success) {
+				ok = platch_decode_value_std(&buffer_cursor, &remaining, &(object_out->std_result));
+				if (ok != 0) return ok;
+			} else {
+				struct std_value error_code, error_msg;
+
+				ok = platch_decode_value_std(&buffer_cursor, &remaining, &error_code);
+				if (ok != 0) return ok;
+				ok = platch_decode_value_std(&buffer_cursor, &remaining, &error_msg);
+				if (ok != 0) return ok;
+				ok = platch_decode_value_std(&buffer_cursor, &remaining, &(object_out->std_error_details));
+				if (ok != 0) return ok;
+
+				if ((error_code.type == kStdString) && ((error_msg.type == kStdString) || (error_msg.type == kStdNull))) {
+					object_out->error_code = error_code.string_value;
+					object_out->error_msg = (error_msg.type == kStdString) ? error_msg.string_value : NULL;
+				} else {
+					return EBADMSG;
+				}
+			}
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+
+int platch_encode(struct platch_obj *object, uint8_t **buffer_out, size_t *size_out) {
+	struct std_value stdmethod, stderrcode, stderrmessage;
+	uint8_t *buffer, *buffer_cursor;
+	size_t   size = 0;
+	int		 ok = 0;
+
+	*size_out = 0;
+	*buffer_out = NULL;
+
+	switch (object->codec) {
+		case kNotImplemented:
+			*size_out = 0;
+			*buffer_out = NULL;
+			return 0;
+		case kStringCodec:
+			size = strlen(object->string_value);
+			break;
+		case kBinaryCodec:
+			*buffer_out = object->binarydata;
+			*size_out = object->binarydata_size;
+			return 0;
+		case kJSONMessageCodec:
+			size = platch_calc_value_size_json(&(object->json_value));
+			size += 1;  // JSONMsgCodec uses sprintf, which null-terminates strings,
+						// so lets allocate one more byte for the last null-terminator.
+						// this is decremented again in the second switch-case, so flutter
+						// doesn't complain about a malformed message.
+			break;
+		case kStandardMessageCodec:
+			ok = platch_calc_value_size_std(&(object->std_value), &size);
+			if (ok != 0) return ok;
+			break;
+		case kStandardMethodCall:
+			stdmethod.type = kStdString;
+			stdmethod.string_value = object->method;
+			
+			ok = platch_calc_value_size_std(&stdmethod, &size);
+			if (ok != 0) return ok;
+
+			ok = platch_calc_value_size_std(&(object->std_arg), &size);
+			if (ok != 0) return ok;
+
+			break;
+		case kStandardMethodCallResponse:
+			size += 1;
+
+			if (object->success) {
+				ok = platch_calc_value_size_std(&(object->std_result), &size);
+				if (ok != 0) return ok;
+			} else {
+				stderrcode = (struct std_value) {
+					.type = kStdString,
+					.string_value = object->error_code
+				};
+				stderrmessage = (struct std_value) {
+					.type = kStdString,
+					.string_value = object->error_msg
+				};
+				
+				ok = platch_calc_value_size_std(&stderrcode, &size);
+				if (ok != 0) return ok;
+				ok = platch_calc_value_size_std(&stderrmessage, &size);
+				if (ok != 0) return ok;
+				ok = platch_calc_value_size_std(&(object->std_error_details), &size);
+				if (ok != 0) return ok;
+			}
+			break;
+		case kJSONMethodCall:
+			size = platch_calc_value_size_json(
+				&JSONOBJECT2(
+					"method", JSONSTRING(object->method),
+					"args", object->json_arg
+				)
+			);
+			size += 1;
+			break;
+		case kJSONMethodCallResponse:
+			if (object->success) {
+				size = 1 + platch_calc_value_size_json(&JSONARRAY1(object->json_result));
+			} else {
+				size = 1 + platch_calc_value_size_json(
+					&JSONARRAY3(
+						JSONSTRING(object->error_code),
+						(object->error_msg != NULL) ? JSONSTRING(object->error_msg) : JSONNULL,
+						object->json_error_details
+					)
+				);
+			}
+			break;
+		default:
+			return EINVAL;
+	}
+
+	buffer = malloc(size);
+	if (buffer == NULL) {
+		return ENOMEM;
+	}
+
+	buffer_cursor = buffer;
+	
+	switch (object->codec) {
+		case kStringCodec:
+			memcpy(buffer, object->string_value, size);
+			break;
+		case kStandardMessageCodec:
+			ok = platch_write_value_to_buffer_std(&(object->std_value), &buffer_cursor);
+			if (ok != 0) goto free_buffer_and_return_ok;
+			break;
+		case kStandardMethodCall:
+			ok = platch_write_value_to_buffer_std(&stdmethod, &buffer_cursor);
+			if (ok != 0) goto free_buffer_and_return_ok;
+
+			ok = platch_write_value_to_buffer_std(&(object->std_arg), &buffer_cursor);
+			if (ok != 0) goto free_buffer_and_return_ok;
+
+			break;
+		case kStandardMethodCallResponse:
+			if (object->success) {
+				_write_u8(&buffer_cursor, 0x00, NULL);
+
+				ok = platch_write_value_to_buffer_std(&(object->std_result), &buffer_cursor);
+				if (ok != 0) goto free_buffer_and_return_ok;
+			} else {
+				_write_u8(&buffer_cursor, 0x01, NULL);
+
+				ok = platch_write_value_to_buffer_std(&stderrcode, &buffer_cursor);
+				if (ok != 0) goto free_buffer_and_return_ok;
+				ok = platch_write_value_to_buffer_std(&stderrmessage, &buffer_cursor);
+				if (ok != 0) goto free_buffer_and_return_ok;
+				ok = platch_write_value_to_buffer_std(&(object->std_error_details), &buffer_cursor);
+				if (ok != 0) goto free_buffer_and_return_ok;
+			}
+			
+			break;
+		case kJSONMessageCodec:
+			size -= 1;
+			ok = platch_write_value_to_buffer_json(&(object->json_value), &buffer_cursor);
+			if (ok != 0) goto free_buffer_and_return_ok;
+			break;
+		case kJSONMethodCall:
+			size -= 1;
+			ok = platch_write_value_to_buffer_json(
+				&JSONOBJECT2(
+					"method", JSONSTRING(object->method),
+					"args", object->json_arg
+				),
+				&buffer_cursor
+			);
+			if (ok != 0) {
+				goto free_buffer_and_return_ok;
+			}
+			break;
+		case kJSONMethodCallResponse: 
+			if (object->success) {
+				ok = platch_write_value_to_buffer_json(
+					&JSONARRAY1(object->json_result),
+					&buffer_cursor
+				);
+			} else {
+				ok = platch_write_value_to_buffer_json(
+					&JSONARRAY3(
+						JSONSTRING(object->error_code),
+						(object->error_msg != NULL) ? JSONSTRING(object->error_msg) : JSONNULL,
+						object->json_error_details
+					),
+					&buffer_cursor
+				);
+			}
+			size -= 1;
+			if (ok != 0) {
+				goto free_buffer_and_return_ok;
+			}
+			break;
+		default:
+			return EINVAL;
+	}
+
+	*buffer_out = buffer;
+	*size_out = size;
+	return 0;
+
+	free_buffer_and_return_ok:
+	free(buffer);
+	return ok;
+}
+
+void platch_on_response_internal(const uint8_t *buffer, size_t size, void *userdata) {
+	struct platch_msg_resp_handler_data *handlerdata;
+	struct platch_obj object;
+	int ok;
+
+	handlerdata = (struct platch_msg_resp_handler_data *) userdata;
+	ok = platch_decode((uint8_t*) buffer, size, handlerdata->codec, &object);
+	if (ok != 0) return;
+
+	ok = handlerdata->on_response(&object, handlerdata->userdata);
+	if (ok != 0) return;
+
+	free(handlerdata);
+
+	ok = platch_free_obj(&object);
+	if (ok != 0) return;
+}
+
+int platch_send(struct fwr_instance *instance, char *channel, struct platch_obj *object, enum platch_codec response_codec, platch_msg_resp_callback on_response, void *userdata) {
+	FlutterPlatformMessageResponseHandle *response_handle = NULL;
+	struct platch_msg_resp_handler_data *handlerdata = NULL;
+	FlutterEngineResult result;
+	uint8_t *buffer;
+	size_t   size;
+	int ok;
+
+	ok = platch_encode(object, &buffer, &size);
+	if (ok != 0) return ok;
+
+	if (on_response) {
+		handlerdata = malloc(sizeof(struct platch_msg_resp_handler_data));
+		if (!handlerdata) {
+			return ENOMEM;
+		}
+		
+		handlerdata->codec = response_codec;
+		handlerdata->on_response = on_response;
+		handlerdata->userdata = userdata;
+
+		result = instance->fl_proc_table.PlatformMessageCreateResponseHandle(instance->engine, platch_on_response_internal, handlerdata, &response_handle);
+		if (result != kSuccess) {
+			fprintf(stderr, "[flutter-pi] Error create platform message response handle. FlutterPlatformMessageCreateResponseHandle: %s\n", FLUTTER_RESULT_TO_STRING(result));
+			goto fail_free_handlerdata;
+		}
+	}
+
+    ok = instance->fl_proc_table.SendPlatformMessage(
+        instance->engine,
+        &(const FlutterPlatformMessage) {
+            .struct_size = sizeof(FlutterPlatformMessage),
+            .channel = channel,
+            .message = buffer,
+            .message_size = size,
+            .response_handle = response_handle
+        }
+    );
+
+	if (ok != 0) {
+		goto fail_release_handle;
+	}
+
+	// TODO: This won't work if we're not on the main thread
+	if (on_response) {
+		result = instance->fl_proc_table.PlatformMessageReleaseResponseHandle(instance->engine, response_handle);
+		if (result != kSuccess) {
+			fprintf(stderr, "[flutter-pi] Error releasing platform message response handle. FlutterPlatformMessageReleaseResponseHandle: %s\n", FLUTTER_RESULT_TO_STRING(result));
+			ok = EIO;
+			goto fail_free_buffer;
+		}
+	}
+
+	if (object->codec != kBinaryCodec) {
+		free(buffer);
+	}
+	
+	return 0;
+
+
+	fail_release_handle:
+	if (on_response) {
+		instance->fl_proc_table.PlatformMessageReleaseResponseHandle(instance->engine, response_handle);
+	}
+
+	fail_free_buffer:
+	if (object->codec != kBinaryCodec) {
+		free(buffer);
+	}
+
+	fail_free_handlerdata:
+	if (on_response) {
+		free(handlerdata);
+	}
+
+	return ok;
+}
+
+int platch_call_std(struct fwr_instance *instance, char *channel, char *method, struct std_value *argument, platch_msg_resp_callback on_response, void *userdata) {
+	struct platch_obj object = {
+		.codec = kStandardMethodCall,
+		.method = method,
+		.std_arg = *argument
+	};
+	
+	return platch_send(instance, channel, &object, kStandardMethodCallResponse, on_response, userdata);
+}
+
+int platch_call_json(struct fwr_instance *instance, char *channel, char *method, struct json_value *argument, platch_msg_resp_callback on_response, void *userdata) {
+	return platch_send(instance, channel,
+								&(struct platch_obj) {
+									.codec = kJSONMethodCall,
+									.method = method,
+									.json_arg = *argument
+								},
+								kJSONMethodCallResponse,
+								on_response,
+								userdata);
+}
+
+int platch_respond(struct fwr_instance *instance, FlutterPlatformMessageResponseHandle *handle, struct platch_obj *response) {
+	uint8_t *buffer = NULL;
+	size_t   size = 0;
+	int ok;
+
+	ok = platch_encode(response, &buffer, &size);
+	if (ok != 0) return ok;
+
+    ok = instance->fl_proc_table.SendPlatformMessageResponse(
+            instance->engine,
+            handle,
+            buffer,
+            size
+        );
+
+	if (buffer != NULL) {
+		free(buffer);
+	}
+
+	return 0;
+}
+
+int platch_respond_not_implemented(struct fwr_instance *instance, FlutterPlatformMessageResponseHandle *handle) {
+	return platch_respond(
+        instance,
+		(FlutterPlatformMessageResponseHandle *) handle,
+		&(struct platch_obj) {
+			.codec = kNotImplemented
+		});
+}
+
+/****************************
+ * STANDARD METHOD CHANNELS *
+ ****************************/
+
+int platch_respond_success_std(struct fwr_instance *instance,
+                               FlutterPlatformMessageResponseHandle *handle,
+							   struct std_value *return_value) {
+	return platch_respond(
+        instance,
+		handle,
+		&(struct platch_obj) {
+			.codec = kStandardMethodCallResponse,
+			.success = true,
+			.std_result = return_value? *return_value : STDNULL
+		}
+	);
+}
+
+int platch_respond_error_std(struct fwr_instance *instance,
+                             FlutterPlatformMessageResponseHandle *handle,
+							 char *error_code,
+							 char *error_msg,
+							 struct std_value *error_details) {
+	return platch_respond(instance, handle, &(struct platch_obj) {
+		.codec = kStandardMethodCallResponse,
+		.success = false,
+		.error_code = error_code,
+		.error_msg = error_msg,
+		.std_error_details = error_details? *error_details : STDNULL
+	});
+}
+
+/// Sends a platform message to `handle` with error code "illegalargument"
+/// and error message `errmsg`.
+int platch_respond_illegal_arg_std(struct fwr_instance *instance,
+                                    FlutterPlatformMessageResponseHandle *handle,
+								   char *error_msg) {
+	return platch_respond_error_std(instance, handle, "illegalargument", error_msg, NULL);
+}
+
+/// Sends a platform message to `handle` with error code "nativeerror"
+/// and error messsage `strerror(_errno)`
+int platch_respond_native_error_std(struct fwr_instance *instance,
+                                    FlutterPlatformMessageResponseHandle *handle,
+									int _errno) {
+	return platch_respond_error_std(
+        instance,
+		handle,
+		"nativeerror",
+		strerror(_errno),
+		&STDINT32(_errno)
+	);
+}
+
+
+/************************
+ * JSON METHOD CHANNELS *
+ ************************/
+
+int platch_respond_success_json(struct fwr_instance *instance,
+                                FlutterPlatformMessageResponseHandle *handle,
+								struct json_value *return_value) {
+	return platch_respond(
+        instance,
+		handle,
+		&(struct platch_obj) {
+			.codec = kJSONMethodCallResponse,
+			.success = true,
+			.json_result = return_value
+				? *return_value
+				: JSONNULL
+		}
+	);
+}
+
+int platch_respond_error_json(struct fwr_instance *instance,
+                              FlutterPlatformMessageResponseHandle *handle,
+							  char *error_code,
+							  char *error_msg,
+							  struct json_value *error_details) {
+	return platch_respond(instance, handle, &(struct platch_obj) {
+		.codec = kJSONMethodCallResponse,
+		.success = false,
+		.error_code = error_code,
+		.error_msg = error_msg,
+		.json_error_details = (error_details) ?
+			*error_details :
+			(struct json_value) {.type = kJsonNull}
+	});
+}
+
+int platch_respond_illegal_arg_json(struct fwr_instance *instance,
+                                    FlutterPlatformMessageResponseHandle *handle,
+                                    char *error_msg) {
+	return platch_respond_error_json(instance, handle, "illegalargument", error_msg, NULL);
+}
+
+int platch_respond_native_error_json(struct fwr_instance *instance,
+                                     FlutterPlatformMessageResponseHandle *handle,
+                                     int _errno) {
+	return platch_respond_error_json(
+        instance,
+		handle,
+		"nativeerror",
+		strerror(_errno),
+		&(struct json_value) {.type = kJsonNumber, .number_value = _errno}
+	);
+}
+
+/**************************
+ * PIGEON METHOD CHANNELS *
+ **************************/
+int platch_respond_success_pigeon(
+    struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	struct std_value *return_value
+) {
+	return platch_respond(
+        instance,
+		handle,
+		&PLATCH_OBJ_STD_MSG(
+			STDMAP1(
+				STDSTRING("result"),
+				return_value != NULL
+					? *return_value
+					: STDNULL
+			)
+		)
+	);
+}
+
+int platch_respond_error_pigeon(
+    struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	char *error_code,
+	char *error_msg,
+	struct std_value *error_details
+) {
+	return platch_respond(
+        instance,
+		handle,
+		&PLATCH_OBJ_STD_MSG(
+			STDMAP1(
+				STDSTRING("error"),
+				STDMAP3(
+					STDSTRING("code"),    STDSTRING(error_code),
+					STDSTRING("message"), STDSTRING(error_msg),
+					STDSTRING("details"), error_details != NULL
+											? *error_details
+											: STDNULL
+				)
+			)
+		)
+	);
+}
+
+int platch_respond_illegal_arg_pigeon(
+    struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	char *error_msg
+) {
+	return platch_respond_error_pigeon(
+        instance,
+		handle,
+		"illegalargument",
+		error_msg,
+		NULL
+	);
+}
+
+int platch_respond_illegal_arg_ext_pigeon(
+    struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	char *error_msg,
+	struct std_value *error_details
+) {
+	return platch_respond_error_pigeon(
+        instance,
+		handle,
+		"illegalargument",
+		error_msg,
+		error_details
+	);
+}
+
+
+int platch_respond_native_error_pigeon(
+    struct fwr_instance *instance,
+	FlutterPlatformMessageResponseHandle *handle,
+	int _errno
+) {
+	return platch_respond_error_pigeon(
+        instance,
+		handle,
+		"nativeerror",
+		strerror(_errno),
+		&STDINT32(_errno)
+	);
+}
+
+/***************************
+ * STANDARD EVENT CHANNELS *
+ ***************************/
+int platch_send_success_event_std(struct fwr_instance *instance, char *channel, struct std_value *event_value) {
+	return platch_send(
+        instance,
+		channel,
+		&(struct platch_obj) {
+			.codec = kStandardMethodCallResponse,
+			.success = true,
+			.std_result = event_value? *event_value : STDNULL
+		},
+		0, NULL, NULL
+	);
+}
+
+int platch_send_error_event_std(struct fwr_instance *instance, 
+                                char *channel,
+							 	char *error_code,
+							 	char *error_msg,
+							 	struct std_value *error_details) {
+	return platch_send(
+        instance,
+		channel,
+		&(struct platch_obj) {
+			.codec = kStandardMethodCallResponse,
+			.success = false,
+			.error_code = error_code,
+			.error_msg = error_msg,
+			.std_error_details = error_details? *error_details : STDNULL
+		},
+		0, NULL, NULL
+	);
+}
+
+/***********************
+ * JSON EVENT CHANNELS *
+ ***********************/
+int platch_send_success_event_json(struct fwr_instance *instance, char *channel, struct json_value *event_value) {
+	return platch_send(instance, channel,
+		&(struct platch_obj) {
+			.codec = kJSONMethodCallResponse,
+			.success = true,
+			.json_result = event_value? *event_value : (struct json_value) {.type = kJsonNull}
+		},
+		0, NULL, NULL
+	);
+}
+
+int platch_send_error_event_json(struct fwr_instance *instance, 
+                                 char *channel,
+								 char *error_code,
+								 char *error_msg,
+								 struct json_value *error_details) {
+	return platch_send(
+        instance,
+		channel,
+		&(struct platch_obj) {
+			.codec = kJSONMethodCallResponse,
+			.success = false,
+			.error_code = error_code,
+			.error_msg = error_msg,
+			.json_error_details = error_details?
+				*error_details :
+				(struct json_value) {.type = kJsonNull}
+		},
+		0, NULL, NULL
+	);
+}
+
+
+bool jsvalue_equals(struct json_value *a, struct json_value *b) {
+	if (a == b) return true;
+	if ((a == NULL) ^ (b == NULL)) return false;
+	if (a->type != b->type) return false;
+
+	switch (a->type) {
+		case kJsonNull:
+		case kJsonTrue:
+		case kJsonFalse:
+			return true;
+		case kJsonNumber:
+			return a->number_value == b->number_value;
+		case kJsonString:
+			return strcmp(a->string_value, b->string_value) == 0;
+		case kJsonArray:
+			if (a->size != b->size) return false;
+			if (a->array == b->array) return true;
+			for (int i = 0; i < a->size; i++)
+				if (!jsvalue_equals(&a->array[i], &b->array[i]))
+					return false;
+			return true;
+		case kJsonObject: {
+			if (a->size != b->size) return false;
+			if ((a->keys == b->keys) && (a->values == b->values)) return true;
+
+			bool _keyInBAlsoInA[a->size];
+			memset(_keyInBAlsoInA, 0, a->size * sizeof(bool));
+
+			for (int i = 0; i < a->size; i++) {
+				// The key we're searching for in b.
+				char *key = a->keys[i];
+				
+				int j = 0;
+				while (j < a->size) {
+					while (_keyInBAlsoInA[j] && (j < a->size))  j++;	// skip all keys with _keyInBAlsoInA set to true.
+					if (strcmp(key, b->keys[j]) != 0)   		j++;	// if b->keys[j] is not equal to "key", continue searching
+					else {
+						_keyInBAlsoInA[j] = true;
+
+						// the values of "key" in a and b must (of course) also be equivalent.
+						if (!jsvalue_equals(&a->values[i], &b->values[j])) return false;
+						break;
+					}
+				}
+
+				// we did not find a->keys[i] in b.
+				if (j + 1 >= a->size) return false;
+			}
+
+			return true;
+		}
+		default:
+			return false;
+	}
+
+	return 0;	
+}
+struct json_value *jsobject_get(struct json_value *object, char *key) {
+	int i;
+	for (i=0; i < object->size; i++)
+		if (strcmp(object->keys[i], key) == 0) break;
+
+
+	if (i != object->size) return &(object->values[i]);
+	return NULL;
+}
+bool stdvalue_equals(struct std_value *a, struct std_value *b) {
+	if (a == b) return true;
+	if ((a == NULL) ^ (b == NULL)) return false;
+
+	DEBUG_ASSERT_NOT_NULL(a);
+	DEBUG_ASSERT_NOT_NULL(b);
+
+	if (a->type != b->type) return false;
+
+	switch (a->type) {
+		case kStdNull:
+		case kStdTrue:
+		case kStdFalse:
+			return true;
+		case kStdInt32:
+			return a->int32_value == b->int32_value;
+		case kStdInt64:
+			return a->int64_value == b->int64_value;
+		case kStdLargeInt:
+		case kStdString:
+			DEBUG_ASSERT_NOT_NULL(a->string_value);
+			DEBUG_ASSERT_NOT_NULL(b->string_value);
+			return strcmp(a->string_value, b->string_value) == 0;
+		case kStdFloat64:
+			return a->float64_value == b->float64_value;
+		case kStdUInt8Array:
+			if (a->size != b->size) return false;
+			if (a->uint8array == b->uint8array) return true;
+
+			DEBUG_ASSERT_NOT_NULL(a->uint8array);
+			DEBUG_ASSERT_NOT_NULL(b->uint8array);
+			for (int i = 0; i < a->size; i++)
+				if (a->uint8array[i] != b->uint8array[i])
+					return false;
+			return true;
+		case kStdInt32Array:
+			if (a->size != b->size) return false;
+			if (a->int32array == b->int32array) return true;
+
+			DEBUG_ASSERT_NOT_NULL(a->int32array);
+			DEBUG_ASSERT_NOT_NULL(b->int32array);
+			for (int i = 0; i < a->size; i++)
+				if (a->int32array[i] != b->int32array[i])
+					return false;
+			return true;
+		case kStdInt64Array:
+			if (a->size != b->size) return false;
+			if (a->int64array == b->int64array) return true;
+
+			DEBUG_ASSERT_NOT_NULL(a->int64array);
+			DEBUG_ASSERT_NOT_NULL(b->int64array);
+			for (int i = 0; i < a->size; i++)
+				if (a->int64array[i] != b->int64array[i])
+					return false;
+			return true;
+		case kStdFloat64Array:
+			if (a->size != b->size) return false;
+			if (a->float64array == b->float64array) return true;
+
+			DEBUG_ASSERT_NOT_NULL(a->float64array);
+			DEBUG_ASSERT_NOT_NULL(b->float64array);
+			for (int i = 0; i < a->size; i++)
+				if (a->float64array[i] != b->float64array[i])
+					return false;
+			return true;
+		case kStdList:
+			// the order of list elements is important
+			if (a->size != b->size) return false;
+			if (a->list == b->list) return true;
+
+			DEBUG_ASSERT_NOT_NULL(a->list);
+			DEBUG_ASSERT_NOT_NULL(b->list);
+			for (int i = 0; i < a->size; i++)
+				if (!stdvalue_equals(a->list + i, b->list + i))
+					return false;
+			
+			return true;
+		case kStdMap: {
+			// the order is not important here, which makes it a bit difficult to compare
+			if (a->size != b->size) return false;
+			if ((a->keys == b->keys) && (a->values == b->values)) return true;
+
+			// _keyInBAlsoInA[i] == true means that there's a key in a that matches b->keys[i]
+			//   so if we're searching for a key in b, we can safely ignore / don't need to compare
+			//   keys in b that have they're _keyInBAlsoInA set to true.
+			bool *_keyInBAlsoInA = alloca(sizeof(bool) * a->size);
+			memset(_keyInBAlsoInA, 0, sizeof(bool) * a->size);
+
+			for (int i = 0; i < a->size; i++) {
+				// The key we're searching for in b.
+				struct std_value *key = a->keys + i;
+				
+				int j = 0;
+				while (j < a->size) {
+					while (_keyInBAlsoInA[j] && (j < a->size))  j++;	// skip all keys with _keyInBAlsoInA set to true.
+					if (stdvalue_equals(key, b->keys + j) == false) {
+						j++;	// if b->keys[j] is not equal to "key", continue searching
+					} else {
+						_keyInBAlsoInA[j] = true;
+
+						// the values of "key" in a and b must (of course) also be equivalent.
+						if (stdvalue_equals(a->values + i, b->values + j) == false) {
+							return false;
+						}
+						break;
+					}
+				}
+
+				// we did not find a->keys[i] in b.
+				if (j + 1 >= a->size) return false;
+			}
+
+			return true;
+		}
+		default: return false;
+	}
+
+	return false;
+}
+struct std_value *stdmap_get(struct std_value *map, struct std_value *key) {
+	DEBUG_ASSERT_NOT_NULL(map);
+	DEBUG_ASSERT_NOT_NULL(key);
+
+	for (int i=0; i < map->size; i++) {
+		if (stdvalue_equals(&map->keys[i], key)) {
+			return &map->values[i];
+		}
+	}
+
+	return NULL;
+}
+struct std_value *stdmap_get_str(struct std_value *map, char *key) {
+	DEBUG_ASSERT_NOT_NULL(map);
+	DEBUG_ASSERT_NOT_NULL(key);
+	return stdmap_get(map, &STDSTRING(key));
+}
\ No newline at end of file
-- 
2.30.2

